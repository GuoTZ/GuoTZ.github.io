{"pages":[{"title":"","text":"欢迎访问我的博客博客地址","link":"/README.html"},{"title":"关于GuoTZ","text":"iOS Developer, Pythoner, Gopher, 谷粉兼果粉, 强迫症患者, 非处女座. 技能 ： 汇编、C、C++、C#、Objective-C、Swift、Python、前端、.NET ：精通iOS开发，精通OC，熟悉Swift ：熟悉HTML、了解CSS、了解JavaScript、了解React ：熟悉Django、了解Flask ：熟悉 ASP.NET 之前状态 学习并实践后端. 目前状态 积累技术, 努力工作, 坚持学习, 认真生活. 实践多线程, flask, 前端，Android.","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"工具连接","text":"格式化JSONMac开源软件一个小工具超多的网站","link":"/links/index.html"},{"title":"resume","text":"","link":"/resume/index.html"}],"posts":[{"title":"Apache学习","text":"Mac自带apache服务器12345sudo apachectl start #开启apache sudo apachectl restart #重启apache sudo apachectl stop #关闭apache mac默认目录/Library/WebServer/Documents/ 12345678910cd /etc/apache2 #切换工作目录下：sudo cp httpd.conf httpd.conf.bak #备份文件，只需要执行一次：sudo cp httpd.conf.bak httpd.conf #如果操作出现错误！可以使用命令，恢复备份的 httpd.conf 文件：sudo vim httpd.conf #用vim编辑httpd.conf文件，httpd.conf文件时Apache的配置文件：#搜索/DocumentRoot，找到对应位置将路径改为自己创建的文件文件夹的路径#之后找到Options FollowSymLinks：修改为Options Indexes FollowSymLinks，在两个单词间添加一个Indexes单词。#接下来查找php，:/php 将代码前面的＃去掉。最后:wq保存并退出cd /etc #切换工作目录：sudo cp php.ini.default php.ini#拷贝php.ini文件：sudo apachectl -k restart #重启","link":"/2017/01/02/Apache学习/"},{"title":"Django入门","text":"Django mysql配置1234567891011底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclientDATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'xxx', 'USER': 'xxx', 'PASSWORD':'xxx', 'HOST': 'localhost', 'PORT': '3306', }} VSCode 运行Django123456789101112131415DEBUG 选择python:Django{ \"name\": \"Python: Django\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/manage.py\", \"console\": \"integratedTerminal\", \"args\": [ \"runserver\", \"8080\",#添加端口号 \"--noreload\", \"--nothreading\" ], \"django\": true}, Django自动生成对象模型12345678910自动生成models模型文件 Python3 manage.py inspectdb 这样就可以在控制台的命令行中看到数据库的模型文件了把模型文件导入到app中 创建一个app python3 manage.py inspectdb &gt; app/models.py 生成单张表python3 manage.py inspectdb api_blog_subject&gt; cms/models/blogSubject.py Django框架使用-生成数据库表12345python3 manage.py makemigrations #会检查数据库定义的代码是否正确.python3 manage.py migratepython3 manage.py flush #清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）python3 manage.py createsuperuser #创建超级管理员 Django setting中 time zone和language code设置中文的问题123456将language code设置为'zh-cn'后每次启动server都提示error，说找不到zh-cn的language code。最后发现改成'zh-hans'即可Django1.9以后language code 'zh-cn'就被丢弃了，使用'zh-hans'代替。TIME_ZONE = 'Asia/Shanghai'LANGUAGE_CODE = 'zh-hans'","link":"/2018/01/13/Django入门/"},{"title":"Django-API插件类","text":"Response的插件类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455\"\"\"定义一个插件类，\"\"\"from django.http import JsonResponse, HttpResponseimport json# 自定义状态码class HttpCode(object): # 正常登陆 ok = 200 # 参数错误 paramserror = 400 # 权限错误 unauth = 401 # 方法错误 methoderror = 405 # 服务器内部错误 servererror = 500# 定义统一的 json 字符串返回格式def result(code=HttpCode.ok, message=\"\", data={}, kwargs=None): json_dict = {} safe = True if not isinstance(data, dict): json_dict = {\"code\": code, \"message\": message, \"data\": list(data)} safe = False else: json_dict = {\"code\": code, \"message\": message, \"data\": data} # print('返回值'+json_dict) return JsonResponse(json_dict,safe=safe)def ok(data={},message=\"\"): return result(code=0, message=message, data=data)# 参数错误def params_error(message=\"\", data={}): return result(code=1, message=message, data=data)# 权限错误def unauth(message=\"\", data={}): return result(code=4, message=message, data=data)# 方法错误def method_error(message=\"\", data={}): return result(code=2, message=message, data=data)# 服务器内部错误def server_error(message=\"\", data={}): return result(code=3, message=message, data=data) request的插件类1234567891011121314151617181920212223242526272829def requestIsGet(view): def decorator( request, *args, **kwargs): print('自定义装饰器被调用了') print('请求路径%s' % request.path) if request.method != 'GET': return reqMethodError(0) return view(request, *args, **kwargs) return decoratordef requestIsPost(view): def decorator( request, *args, **kwargs): print('自定义装饰器被调用了') print('请求路径%s' % request.path) if request.method != 'POST': return reqMethodError(0) return view(request, *args, **kwargs) return decoratordef reqMethodError(type): msg = '' if type == 0 : msg = '请求方式错误，应该为Get请求' elif type == 1 : msg = '请求方式错误，应该为Get请求' return resultApi.method_error(msg)def page_not_found(request): print ('404') return render(request, 'blogs/404.html') 插件类的使用1234@requestIsGetdef index(request): data = {} return resultApi.ok(data)","link":"/2019/03/26/Django-API插件类/"},{"title":"Nginx学习二","text":"未完待续","link":"/2017/01/29/Nginx学习二/"},{"title":"Python 虚拟机","text":"virtualenvwrapper1virtualenvwrapper 是一个基于 virtualenv 之上的工具，它将所有的虚拟环境集中起来管理。 安装sudo pip install virtualenvwrapper 配置1234vim ~/.bashrcexport WORKON_HOME=~/workspaces #存放虚拟环境的位置source /usr/bin/virtualenvwrapper.sh 使用12345mkvirtualenv env1 #创建workon env1 #切换虚拟机cpvirtualenv env1 env3 #赋值虚拟机rmvirtualenv env2 #删除虚拟机pip list #查看虚拟机中的packages 其他命令1234lsvirtualenv #显示所有虚拟环境。cdvirtualenv #跳转至当前虚拟环境目录，方便查看虚拟环境的 site-packages 目录。cdsitepackages #直接跳转至当前虚拟环境的 site-packages 目录。lssitepackages #显示当前虚拟环境的 site-packages 目录内容。","link":"/2017/04/30/Python-虚拟机/"},{"title":"Mac FTP相关操作","text":"安装ftp命令123brew install telnet brew install inetutils brew link --overwrite inetutils ftp的使用登录 方式一 ftp server-ip 方式二 12345678910111213ftpftp&gt; open server-ip#ftp登录还有其他方式，这里只介绍两种。#以上命令之后，按提示输入用户名和密码。#当出现以下日志，表示连接成功#Connected to server-ip#220 (vsFTPd 2.2.2)#Name (10.0.5.11:lipengxiang): username#331 Please specify the password.#Password:#230 Login successful.#此时已经进入ftp命令行环境，此时如果进行本地目录或文件操作命令将发生一些变化，如下： 服务器操作 本地目录操作 cd 目录名（进入服务器目录） lcd 目录名（进入本机目录） cd \\（退到服务器根目录） lcd \\（退到本机根目录） cd ..（退回到上一级目录） lcd ..（退回到上一级目录） pwd !pwd ls !ls 上传文件server-filename 必须显式指明，否则报错：文件名无效 ftp&gt; put /local/path/filename /remote/path/server-filename 注意：向ftp服务器上传文件有两种模式 字符模式（ASCII）和二进制模式（Binary）。默认是ASCII模式。一般上传非文本文件要用二进制模式。登录ftp后，上传文件前，在ftp&gt;状态下输入bin即可(切换为二进制模式)。在ftp&gt;状态下输入asc(切换为ASCII模式) 批量上传使用通匹符批量上传文件至服务器，需要注意的一点，mput 不支持绝对路径，应该先进入要上传的本地文件夹及远程文件夹才可以操作。12345ftp&gt; cd /remote/pathftp&gt; lcd /local/pathftp&gt; mput file*local: file.jar remote: file.jar #注意：ftp不支持文件夹上传 文件下载下载服务器中的文件至本地目录中，可选指定下载至本地目录后的文件名称，依然要求提前进入待下载文件的目录中。123ftp&gt; get remote-filename local-filenamelocal-filename可省略，默认本地当前路径。#注意：关于下载文件夹， FTP 命令不支持文件夹下载操作。 删除文件ftp&gt; delete /remote/path/filename在服务器中删除文件，可以指定绝对路径，相对其他命令显得比较灵活。","link":"/2017/01/06/Mac-FTP相关操作/"},{"title":"Swift面向协议 POP","text":"基于 Swift 的面向协议编程12面向对象的设计和面向协议的设计都使用了多态让我们使用同样的接口来跟不同的类型进行交互。在面向对象的设计中，我们使用了基类提供的接口来跟所有的子类进行交互。在面向协议的设计中，我们使用了协议和协议扩展提供的接口来跟遵守该协议的类型进行交互。两种设计方式写出的代码都很好而且易懂。但个人感觉协议/协议扩展代码更好，因为协议/协议扩展的方法整体更干净和易懂些。' 12在面向协议设计中我们更多的使用了值类型（结构体struct）而非引用类型（类class）。Apple已经说了我们应该在合适的地方尽可能地偏好使用值类型而非引用类型。 未完待续","link":"/2019/05/04/Swift面向协议-POP/"},{"title":"Nginx学习一","text":"nginx的安装1234conf 配置文件html 网页文件logs log日志sbin 二进制文件 nginx其他命令1234ps aux|grep nginx 查看nginxcat nginx.pid 查看进程号killall -9 nginx 杀死进程kill -USR2 进程号 控制命令123456kill -USR2 cat nginx.pid #不是杀进程相当于重启nginx -t #检测配置是否成功nginx -s reload #重新加载配置文件nginx -s stop #立即停止nginx -s quit #优雅的停止 及当前访问的进程不加载🆕配置nginx -s reopen #重新加载日志配置 配置文件nginx.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#指定用什么用户去跑work process，默认用linux下的nobody用户 #user nobody; #工作进程数,可以设置为auto,nginx会探测cpu核心数，启动相同数量的work processworker_processes 1; #错误日志存放位置.既然叫错误日志，通常应设置级别为warn|error#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#主进程pid文件存放的地点#pid logs/nginx.pid;#events模块只能在main上下文中，并且只能配置一个，#其中可以包含7种简单指令events { worker_connections 1024; #每个worker process可以支持的最大连接数，生成环境根据需要可以设置更大一些（9000） #值得注意的是，此数字是包括了反向代理等等所需要的连接数在内，并不仅仅是指web端发起的连接数 #multi_accept on #是否work进程一次只接收一个连接。并发较大时应打开 #use epoll #选择底层处理连接的模型，Linux下默认epoll，无需自己设置 #accept_mutex #accept_mutex_delay #上面2参数是表示是否让worker进程使用one by one的工作模式，默认是关闭的。 #开启的时候，在低并发的时候非工作状态下的worker process将休眠，避免浪费资源。}#nginx配置的“核心”http { #include指令用于加载单独的配置文件模块，避免过于臃肿 #而这里的mime.types表示此文件应该在nginx.conf的同级目录下。 #其中的types模块用于表示nginx响应的文件后缀名和content-type直接的映射 #比如你想要让浏览器识别你返回的mytxt.data文件为文本内容在浏览器中显示为文本,添加 text/plain data; include mime.types; #上面的匹配失败后，默认给的响应内容类型 default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #io时不阻塞处理connection，在传输大文件时使用，细节待研究 sendfile on; #tcp_nopush on;#貌似意思是只有在sendfile启用时使用，让nginx发包的时候满包发送（不明白）通常不使用 #连接idle的最大时间，现代浏览器往往在一个页面同时打开多个connection传输js,css,html等。 #设置最大idle时间避免过长等待浪费connection #keepalive_timeout 0; keepalive_timeout 65; #开启response响应压缩，可以节省带宽，默认关闭。细节待研究 #gzip on; #server 上下文代表一个虚拟主机，可以有多个，内嵌在比如http,mail模块中 server { listen 80; server_name myapp.info; #如果是在本地试验，要修改/etc/hosts的域名映射到本机 location / { #location的匹配规则too tricky，单开一篇blog 注意匹配的文件夹的访问权限 root /usr/local/nginx; } } } 12worker_processes 一般为CPU数×核数关键还需看网卡的吞吐量 server配置虚拟主机123456Apache下配置&lt;virturlhost&gt; servername 域名 documentroot 路径&lt;/virturlhost&gt;说明该域名指向路径就行了 12345678nginx配置server { listen 80; server_name 域名; location / { root 文件路径; index index.php index.html; }","link":"/2017/01/23/Nginx学习一/"},{"title":"centos下搭建svn","text":"centos7 Linuxsvn安装配置 安装svn yum -y install subversion 创建svn根文件夹mkdir /var/svns 配置文件夹 123vim /etc/sysconfig/svnserve#文件内容OPTIONS=\"-r /var/svns\" svn创建版本库 创建svn版本库svnadmin create /var/svns/xxxx 1234#版本库的conf文件夹authz：#负责账号权限的管理，控制账号是否读写权限passwd：#负责账号和密码的用户名单管理svnserve.conf：#svn服务器配置文件 vim svnserve.conf 12345anon-access = none #表示禁止匿名用户访问。auth-access = write #表示授权用户拥有读写权限。password-db = passswd #指定用户名口令文件，即 passwd 文件。authz-db = authz #指定权限配置文件，即 authz 文件。realm = /var/svnrepos #指定认证域，即 /var/svnrepos 目录。 vim passwd 12[users] #下面添加admin = rw #设置读写权限 vim authz 12[/]admin = password #账号密码 svn命令控制123killall svnserve #杀掉svn进程svnserve -d -r /var/svns #启动svnps -ef | grep svn #看服务启动是否成功 mac地址测试 svn co svn://ip地址:3690/xxxx centos7 防火墙开放svn通过12firewall-cmd --permanent --add-port=3690/tcpsystemctl restart firewalld","link":"/2017/01/27/centos下搭建svn/"},{"title":"Swift  Result<T, E: Error> 枚举类型","text":"Swift 枚举类型Swift 中枚举的能力相比 OC 有着很大的进步，每个枚举值除了可以是常规的基础类型，还可以是一个关联的类型。有了这样的特性后用枚举来优化返回结果的数据结构显得水到渠成： 12345678enum Result&lt;Success, Failure&gt; where Failure : Error { /// A success, storing a `Success` value. case success(Success) /// A failure, storing a `Failure` value. case failure(Failure)} 基本用法定义异步返回结果是 Int 类型的函数：123456789101112func fetchData(_ completionHandler: @escaping (Result&lt;Int, Error&gt;) -&gt; Void) { DispatchQueue.global().async { let isSuccess = true if isSuccess { let resultValue = 6 return completionHandler(.success(resultValue)) } else { let error = NSError(domain: \"custom error\", code: -1, userInfo: nil) return completionHandler(.failure(error)) } }} 返回值的类型通过泛型进行约束， Result 第一个泛型类型表示返回值的类型，第二个类型表示错误的类型。对 Result 赋值和常规的枚举一样：1let valueResult: Result&lt;Int, CustomError&gt; = Result.success(4) // 因为 swift 中会进行类型推断，编译器在确认返回的是 Result 类型后，可以省略枚举类型的声明let errorResult = .failure(CustomError.inputNotValid)取出 Result 值和获取普通的关联类型枚举是一样的：12345678fetchData { (result) in switch result { case .success(let value): print(value) case .failure(let error) print(error.localizedDescription) }} 如果你只想要获取其中一项的值，也可以直接用 if case 拆包：12345fetchDate { (result) in if case .success(let value) = result { print(value) }} 可以判等Enum 是一个值类型，是一个值就应该可以判断是否相等。如果 Result 的成功和失败的类型都是 Equatable，那么 Result 就可以判等，源码如下：1extension Result : Equatable where Success : Equatable, Failure : Equatable { } 类似的，如果是成功和失败的类型都是 Hashable，那么 Result 也是 Hashable：1extension Result : Hashable where Success : Hashable, Failure : Hashable { } 如果实现了 Hashable ，可以用来当做字典的 key。 辅助的 APImap、mapError与 Dictionary 类似，Swift 为 Result 提供了几个 map value 和 error 的方法。1234567891011let intResult: Result&lt;Int, Error&gt; = Result.success(4)let stringResult = x.map { (value) -&gt; Result&lt;String, Error&gt; in return .success(\"map\")}let originError = NSError(domain: \"origin error\", code: -1, userInfo: nil)let errorResult: Result&lt;Int, Error&gt; = .failure(originError)let newErrorResult = errorResult.mapError { (error) -&gt; Error in let newError = NSError(domain: \"new error\", code: -2, userInfo: nil) return newError} flatMap、flatMapErrormap 返回的是具体的结果和错误， flatMap 闭包中返回的是 Result 类型。如果 Result 中包含的是数据，效果和 map 一致，替换数据；如果 Result 中包含的是错误，那么不替换结果。1234567891011let intResult: Result&lt;Int, Error&gt; = Result.success(4)// 替换成功let flatMapResult = intResult.flatMap { (value) -&gt; Result&lt;String, Error&gt; in return .success(\"flatMap\")}// 没有执行替换操作，flatMapIntResult 值还是 intResultlet flatMapIntResult = intResult.flatMap { (value) -&gt; Result&lt;String, Error&gt; in return .failure(NSError(domain: \"origin error\", code: -1, userInfo: nil))} get很多时候只关心 Result 的值， Swift 提供了 get() 函数来便捷的直接获取值，需要注意的是这个函数被标记为 throws，使用时语句前需要加上 try：123let intResult: Result&lt;Int, Error&gt; = Result.success(4)let value = try? intResult.get() 可抛出异常的闭包初始化器很多时候获取返回值的闭包中可能会发生异常代表获取失败的错误，基于这个场景 Swift 提供了一个可抛出异常的闭包初始化器：12345678910111213enum CustomError: Error, Equatable { case inputNotValid}let fetchInt = { () -&gt; Int in if true { return 4 } else { throw CustomError.inputNotValid }}let result: Result&lt;Int, Error&gt; = Result { try fetchInt() } 需要提醒是通过这种方式声明的 Result 的 error 类型只能是 Error，不能指定特定的 Error。","link":"/2019/05/03/Swift-Result-T-E-Error-枚举类型/"},{"title":"RESTAPI 安全设计","text":"RESTAPI的安全处理—以Django为例1、使用Token机制AES的加密方式加密token包含内容 包含加密密码字符串 1appkey：双方约定值；用于AES加密的密码 包含设备相关信息，设备唯一码 可做踢下线功能 包含用户相关信息 可验证用户信息 包含时间相关信息 可判断登录时效 可包含其他相关信息 例如：经纬度等等 由客户端登录之后向服务器获取token值,服务端获取到deviceId跟userId、当前时间戳根据appkey由AES加密生成token信息，返回给用户端，一般情况下用户端在发起网络请求是在header中携带token信息 2、加密Post请求参数机制RSA的加密方式加密 生成一对公、私钥，公钥分派给客户端 在使用时：客户端先把给服务端的参数序列化成json串，再使用公钥加密，然后base64编码后传给服务器 服务器在收到请求时，使用私钥解密可获得参数 一般使用在登录、获取token、下单等重要接口中 iOS端使用iOSRsa,Ase,Base64加密工具123456789101112UserModel *model = [UserModel new];model.Id = 100;model.name = @\"hjaskdh\";model.userName = @\"hjkasfyhuisa\";NSString *pubkey = @\"-----BEGIN PUBLIC KEY-----\\MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwRu9ANZ3OwzbgoszQxuF5MSUB\\sBgYGX0KQ8xO+Qdd2cmrkw5QljcXdOAhKNYZbBEKxd8RmWVKF81ZEQgqIRKwcNEO\\vv4mJTSfG0PJHXZj+racvWqSVEVl0IgglU+RpJ/W1pBNFzBwN6jW74eyof9epxUo\\NmwSIThRcy5XIQ/P5QIDAQAB\\-----END PUBLIC KEY-----\";NSString *jsonStr = [model modelToJSONString];//转换层字符串NSString *json = [[RSA encryptString:jsonStr publicKey:pubkey] base64EncodedString];//加密 PHP端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php/**私钥*/define('RSA_PRIVATE','-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALBG70A1nc7DNuCizNDG4XkxJQGwGBgZfQpDzE75B13ZyauTDlCWNxd04CEo1hlsEQrF3xGZZUoXzVkRCCohErBw0Q6+/iYlNJ8bQ8kddmP6tpy9apJURWXQiCCVT5Gkn9bWkE0XMHA3qNbvh7Kh/16nFSg2bBIhOFFzLlchD8/lAgMBAAECgYAhD+zn2iaTFUJBt8c6kVLQ7ErImkKqon01Y6n6VfLvw11z9M0GiGYk3CL9lS8y7XX001AXePHqh7RYND2XyUQ7y6YEAY/1Q8zOtp1ustSABt6QfmuVfBJ02tKEAxTkA/G94yKpO49Mbs5+PCXI6Z+K9COwqVYV9kH6qrisnwawsQJBAOj+VNfHkIA3KAapM+J8r5Zf1ywaREuBhU1d1t98psro6Oo9+dkX1r393NGd0Od2x5ZdJih3epDrdcoAk9mT7IcCQQDBrullgZWmR6N+pk0/ku24QfVdaYxwEOp7g53Q9oIIqaVDCCzKygq6VfulCS7Mmf00kZZRdaXim6V/ShnB4AczAkEAonoppEgQprjP+sUn33tf3xd6r9Cpa5Yo5WjZHQSKM9n0AtWxVAjhwaA0yyCou6EDUgInR/T5zfHFNFbuw736JQJAB49KMNoT+z+ElCbtkPOtL6nzZ8f84UrnvBZxDHzyql/kwW8KQIgOTyOYBOMM3pOMHIcqNNfAt82XchZ0VurlnQJBALmW42kRMNA0dR5zD5OBt5LDFux5Qiq9jus6dfcqF8LE4oH43WO/9mt987h7SyKngBiF+7KgH8qJYECdDifODks=-----END PRIVATE KEY-----');/**公钥*/define('RSA_PUBLIC', '-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwRu9ANZ3OwzbgoszQxuF5MSUBsBgYGX0KQ8xO+Qdd2cmrkw5QljcXdOAhKNYZbBEKxd8RmWVKF81ZEQgqIRKwcNEOvv4mJTSfG0PJHXZj+racvWqSVEVl0IgglU+RpJ/W1pBNFzBwN6jW74eyof9epxUoNmwSIThRcy5XIQ/P5QIDAQAB-----END PUBLIC KEY-----');class Test1 extends Base{ /** * 验证登录 * */ protected $uid; public function __construct() { if (is_numeric(parent::__construct())) { $this-&gt;uid = parent::__construct(); } else { echo parent::__construct(); exit; } } //意见反馈提交 public function index() { if (parent::getMethod() != 'true') { echo parent::getMethod(); exit; } $uid = $this-&gt;uid; $orderId = input('get.orderId'); $private_key = openssl_pkey_get_private(RSA_PRIVATE); if (!$private_key) { die('私钥不可用'); } $return_de = openssl_private_decrypt(base64_decode(base64_decode($orderId)), $decrypted, $private_key); if (!$return_de) { return('解密失败,请检查RSA秘钥---------'.$orderId); } $arr = json_decode($decrypted,true); return jsonReturnApi('操作失败', -1, $arr); }}","link":"/2019/05/05/Django-RESTfulAPI-安全设计/"},{"title":"算法-：排序算法","text":"比较排序 定义1 (基于比较的排序)给定一个包含n个对象的待排序序列a1a2…an. 假设我们知道如何比较其中任意两个对象的大小关系。只如何对这一序列排序 121. 传递性：如果a&lt;=b ,b&lt;=c,则一定有a&lt;=c2. 全序性：对任意a和b，或者a&lt;=b，或者b&lt;=c 定义2 (合并多个有序列)将n个序列合并为一个序列。 定义3(前k小数)给定一个包含n个对象的序列 找出前k个最小的数 1. 梳排序12345678冒泡排序for i＝0,2,…,n-1 do for j＝1,2,…,n-i do if aj＞aj+1 then 交换aj和aj+1 endif endifendif 12345678910111213public void bubbleSort(int[] a) { boolean exchange; for(int i = a.length - 1; i &gt; 0; i--) { exchange = false; for(int j = 0; j &lt; i; j++) { if(a[j] &gt; a[j+1]) { swap(a, j, j+1); exchange = true; } } if(!exchange) return; }} 123456789101112梳排序j←n,s←1.3,flag←falseWhile j＞1或者flag＝true do i←0，j←max{|j/s|，1}，flag＝false while i+j ≦ n do If ai ＞ ai＋j then 交换ai和ai＋j flag←true endif i←i＋1 end whileend while 2. 堆排序12 3. 归并排序4. 快速排序5. 内省培训6. Timsort非比较排序1. 桶排序2. 基数培训","link":"/2018/03/12/算法-：排序算法/"},{"title":"博客入门","text":"欢迎使用 GuoTZ 版 博客博客 所使用的 Markdown 语法为 Github Flavored Markdown，简称 GFM，这是一种最为广泛使用的 Markdown 语法之一。如果你不知道什么是 Markdown，建议看一下附带的 Markdown 语法官方说明 文档。GFM 除了支持官方的语法外，还扩展了不少语法。 GuoTZ 版 博客 的主要界面和功能1[Markdown 语法官方说明](Markdown Syntax.md) Markdown 语法官方说明 1![展示图片](http://uploads.scratch.mit.edu/projects/thumbnails/120894657.png) 回车转为换行官方的语法规定结尾加 2 个以上空格加换行才会转成换行，也就是 &lt;br /&gt; 标签。MWeb 中有个选项可以直接把换行转成 &lt;br /&gt;，不用加上 2 个以上空格，这个选项默认是开启的。如果要关闭，请在设置页面关闭。 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片大小及对齐官方和 GFM 都不支持图片大小控制及对齐设置。 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) }} 效果如下： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) }} 这个语法目前在 博客 中使用，必须前后空一行，才会正确解析。我觉得，在写 Markdown 文档过程中，运用空行很有必要，基本上，块级元素（标题、列表、引用、代码块、表格、段落等），都建议前后空一行。 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： ~~删除这些~~ 效果如下： 加删除线像这样用： 删除这些 LaTeXMarkdown 语法： 12345678块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（在设置页面中启用 LaTeX 才会看到效果，默认为启用）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 注 阅读更多的功能只用在文档库生成静态网站或发布到 Wordpress 博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC] markdown语法高亮 Apache Bash C# C++ CSS CoffeeScript Diff HTML, XML HTTP Ini, TOML JSON Java JavaScript Makefile Markdown Nginx Objective-C PHP Perl Properties Python Ruby SQL Shell Session Other Swift TP agger Script TypeScript VB.NET Vim new “算法-：排序算法”servergeneratedeploy","link":"/2016/12/12/博客入门/"},{"title":"iOS脚本自动打包发布及自动检测更新","text":"使用到的第三方平台 蒲公英 集成蒲公英SDK 1234pod 'PgyUpdate'//启动更新检查SDK[[PgyUpdateManager sharedPgyManager] startManagerWithAppId:@\"appkey\"];//在蒲公英平台获取[[PgyUpdateManager sharedPgyManager] checkUpdate]; 由于蒲公英平台更新APP的条件是根据Version和build的值判断更新，所以每次打包时build加1 iOS手动打包添加脚本打包build自增 选择build phases， 在其中添加run Script 脚本，其内容如下： 123456if [ \"$CONFIGURATION\" != \"Debug\" ]thenbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"fi 自动打包脚本 在脚本的编译开始时添加如下代码 12345# 工程的Bundle +1buildNumber=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/${project_name}/Info.plist)echo $buildNumberbuildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c /usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/@{project_name}/Info.plist 上传到测试平台 123456#上传到Fir# 将XXX替换成自己的Fir平台的token#fir login -T XXX#fir publish $exportIpaPath/$scheme_name.ipaipaPath=${exportIpaPath}/${scheme_name}.ipacurl -F file=@${ipaPath} -F '_api_key=XXX' https://www.pgyer.com/apiv2/app/upload 自动化打包脚本 选择打包平台app-store 或者ad-hoc 选择App Store时打包完成上传到App Store 选择adhoc时上传到对应的平台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#使用方法if [ ! -d ./IPADir ];thenmkdir -p IPADir;fi#工程绝对路径project_path=$(cd `dirname $0`; pwd)#工程名 将XXX替换成自己的工程名project_name=XXX#scheme名 将XXX替换成自己的sheme名scheme_name=XXX#打包模式 Debug/Releasedevelopment_mode=Debug#build文件夹路径build_path=${project_path}/build#plist文件所在路径exportOptionsPlistPath=${project_path}/exportTest.plist#导出.ipa文件所在路径exportIpaPath=${project_path}/IPADir/${development_mode}echo \"请输入要导出的的平台 ? [ 1:app-store 2:ad-hoc] \"##read numberwhile([[ $number != 1 ]] &amp;&amp; [[ $number != 2 ]])doecho \"报错! 只能选择平台 1 或 2\"echo \"请重新输入要导出的的平台 ? [ 1:app-store 2:ad-hoc] \"read numberdoneif [ $number == 1 ];thendevelopment_mode=ReleaseexportOptionsPlistPath=${project_path}/exportAppstore.plistelsedevelopment_mode=ReleaseexportOptionsPlistPath=${project_path}/exportTest.plistfi#note: Using new build systemerror: Could not delete `XXX` because it was not created by the build system.rm -rf ${build_path}echo '///-----------'echo '/// 正在清理工程'echo '///-----------'xcodebuild \\clean -configuration ${development_mode} -quiet || exitecho '///--------'echo '/// 清理完成'echo '///--------'echo ''echo '///-----------'echo '/// 正在编译工程:'${development_mode}echo '///-----------'# 工程的Bundle +1buildNumber=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/${project_name}/Info.plist)echo $buildNumberbuildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c /usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/@{project_name}/Info.plist#编译工程xcodebuild \\archive -workspace ${project_path}/${project_name}.xcworkspace \\-scheme ${scheme_name} \\-configuration ${development_mode} \\-archivePath ${build_path}/${project_name}.xcarchive -quiet || exitecho '///--------'echo '/// 编译完成'echo '///--------'echo ''echo '///----------'echo '/// 开始ipa打包'echo '///----------'xcodebuild -exportArchive -archivePath ${build_path}/${project_name}.xcarchive \\-configuration ${development_mode} \\-exportPath ${exportIpaPath} \\-exportOptionsPlist ${exportOptionsPlistPath} \\-quiet || exitif [ -e $exportIpaPath/$scheme_name.ipa ]; thenecho '///----------'echo '/// ipa包已导出'echo '///----------'open $exportIpaPathelseecho '///-------------'echo '/// ipa包导出失败 'echo '///-------------'fiecho '///------------'echo '/// 打包ipa完成 'echo '///-----------='echo ''echo '///-------------'echo '/// 开始发布ipa包 'echo '///-------------'if [ $number == 1 ];then#验证并上传到App Store# 将-u 后面的XXX替换成自己的AppleID的账号，-p后面的XXX替换成自己的密码altoolPath=\"/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool\"\"$altoolPath\" --validate-app -f ${exportIpaPath}/${scheme_name}.ipa -u XXX -p XXX -t ios --output-format xml\"$altoolPath\" --upload-app -f ${exportIpaPath}/${scheme_name}.ipa -u XXX -p XXX -t ios --output-format xmlelse#上传到Fir# 将XXX替换成自己的Fir平台的token#fir login -T XXX#fir publish $exportIpaPath/$scheme_name.ipaipaPath=${exportIpaPath}/${scheme_name}.ipacurl -F file=@${ipaPath} -F '_api_key=XXX' https://www.pgyer.com/apiv2/app/uploadfiexit 0 exportTest.plist 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;ad-hoc&lt;/string&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt;&lt;/dict&gt;&lt;/plist&gt; exportAppstore.plist 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;uploadBitcode&lt;/key&gt; &lt;true/&gt; &lt;key&gt;uploadSymbols&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt;","link":"/2017/05/18/iOS脚本自动打包发布及自动检测更新/"},{"title":"iOS 开发相关开源库","text":"1、腾讯开源，提高项目 UI 开发效率的解决方案：QMUI_iOS 2、iOS 组件化、解藕最佳方案，最强大的动态路由库：FFRouter 3、iOS逆向开发工具：MonkeyDev 4、自动创建带有调试信息的appIcon的脚本：LLIconVersioning 5、iOS 性能分析和测试框架：DetoxInstruments 6、WebView OC与JS通信框架：WebViewJavascriptBridge 7、一个简单的UITableView/UICollectionView的superclass category，用于无数据时自动显示空视图：DZNEmptyDataSet 8、iOS代码自动翻新(混淆)工具：WHC_ConfuseSoftware 9、一个可以观看国内主流视频平台所有vip视频的Mac客户端：ivideo 10、开屏广告、启动广告解决方案-支持静态/动态图片广告,mp4视频广告,全屏/半屏广告：XHLaunchAd 11、一款功能强大的 macOS 版微信小助手，支持防撤回、多开、自动回复：WeChatPlugin-MacOS 12、iOS APP内调试工具，支持抓包、Crash收集、沙盒文件浏览等：LLDebugTool 13、一款iOS苹果远程推送测试程序,Mac OS 下的 APNS 工具：SmartPush 14、Mac里provisionprofile和mobileprovision文件管理器工具：ProfilesManager 15、iOS跑马灯大全：MarqueeLabel 16、支持iOS/tvOS/OSX的漂亮图表、统计图：Charts 17、一行代码设置状态栏、导航栏按钮、标题、颜色、透明度，移动等：WRNavigationBar 18、用于原生渲染After Effects矢量动画的iOS库：lottie-ios 19、Core Data和SQLite的替代品：realm-cocoa 20、Mac OS开源密码存储工具：MacPass","link":"/2016/12/13/iOS-开发相关开源库/"}],"tags":[{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"MD5加密","slug":"MD5加密","link":"/tags/MD5加密/"},{"name":"RSA加密","slug":"RSA加密","link":"/tags/RSA加密/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"第三方库","slug":"第三方库","link":"/tags/第三方库/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"Nginx服务器","slug":"后端/Nginx服务器","link":"/categories/后端/Nginx服务器/"},{"name":"Apache服务器","slug":"后端/Apache服务器","link":"/categories/后端/Apache服务器/"},{"name":"Django","slug":"后端/Django","link":"/categories/后端/Django/"},{"name":"系统","slug":"系统","link":"/categories/系统/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"Mac","slug":"系统/Mac","link":"/categories/系统/Mac/"},{"name":"Swift","slug":"iOS/Swift","link":"/categories/iOS/Swift/"},{"name":"Linux","slug":"系统/Linux","link":"/categories/系统/Linux/"},{"name":"排序算法","slug":"算法/排序算法","link":"/categories/算法/排序算法/"},{"name":"编译","slug":"iOS/编译","link":"/categories/iOS/编译/"},{"name":"Objective-C","slug":"iOS/Objective-C","link":"/categories/iOS/Objective-C/"}]}