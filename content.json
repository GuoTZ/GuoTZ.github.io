{"pages":[{"title":"工具连接","text":"格式化JSONMac开源软件一个小工具超多的网站JSON转对象,待完成IPython Jupyter","link":"/links/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于GuoTZ","text":"iOS Developer, Pythoner, 谷粉兼果粉, 强迫症患者, 非处女座. 技能 ： 汇编、C、C++、C#、Objective-C、Swift、Python、前端、.NET ：精通iOS开发，精通OC，熟悉Swift ：熟悉HTML、了解CSS、了解JavaScript、了解React ：熟悉Django、了解Flask ：熟悉 ASP.NET 之前状态 学习并实践后端. 目前状态 积累技术, 努力工作, 坚持学习, 认真生活. 实践多线程, flask, 前端，Android.","link":"/about/index.html"},{"title":"resume","text":"","link":"/resume/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"RESTAPI 安全设计","text":"RESTAPI的安全处理—以Django为例1、使用Token机制AES的加密方式加密token包含内容 包含加密密码字符串 1appkey：双方约定值；用于AES加密的密码 包含设备相关信息，设备唯一码 可做踢下线功能 包含用户相关信息 可验证用户信息 包含时间相关信息 可判断登录时效 可包含其他相关信息 例如：经纬度等等 由客户端登录之后向服务器获取token值,服务端获取到deviceId跟userId、当前时间戳根据appkey由AES加密生成token信息，返回给用户端，一般情况下用户端在发起网络请求是在header中携带token信息 2、加密Post请求参数机制RSA的加密方式加密 生成一对公、私钥，公钥分派给客户端 在使用时：客户端先把给服务端的参数序列化成json串，再使用公钥加密，然后base64编码后传给服务器 服务器在收到请求时，使用私钥解密可获得参数 一般使用在登录、获取token、下单等重要接口中 iOS端使用iOSRsa,Ase,Base64加密工具123456789101112UserModel *model = [UserModel new];model.Id = 100;model.name = @\"hjaskdh\";model.userName = @\"hjkasfyhuisa\";NSString *pubkey = @\"-----BEGIN PUBLIC KEY-----\\MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwRu9ANZ3OwzbgoszQxuF5MSUB\\sBgYGX0KQ8xO+Qdd2cmrkw5QljcXdOAhKNYZbBEKxd8RmWVKF81ZEQgqIRKwcNEO\\vv4mJTSfG0PJHXZj+racvWqSVEVl0IgglU+RpJ/W1pBNFzBwN6jW74eyof9epxUo\\NmwSIThRcy5XIQ/P5QIDAQAB\\-----END PUBLIC KEY-----\";NSString *jsonStr = [model modelToJSONString];//转换层字符串NSString *json = [[RSA encryptString:jsonStr publicKey:pubkey] base64EncodedString];//加密 PHP端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php/**私钥*/define('RSA_PRIVATE','-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALBG70A1nc7DNuCizNDG4XkxJQGwGBgZfQpDzE75B13ZyauTDlCWNxd04CEo1hlsEQrF3xGZZUoXzVkRCCohErBw0Q6+/iYlNJ8bQ8kddmP6tpy9apJURWXQiCCVT5Gkn9bWkE0XMHA3qNbvh7Kh/16nFSg2bBIhOFFzLlchD8/lAgMBAAECgYAhD+zn2iaTFUJBt8c6kVLQ7ErImkKqon01Y6n6VfLvw11z9M0GiGYk3CL9lS8y7XX001AXePHqh7RYND2XyUQ7y6YEAY/1Q8zOtp1ustSABt6QfmuVfBJ02tKEAxTkA/G94yKpO49Mbs5+PCXI6Z+K9COwqVYV9kH6qrisnwawsQJBAOj+VNfHkIA3KAapM+J8r5Zf1ywaREuBhU1d1t98psro6Oo9+dkX1r393NGd0Od2x5ZdJih3epDrdcoAk9mT7IcCQQDBrullgZWmR6N+pk0/ku24QfVdaYxwEOp7g53Q9oIIqaVDCCzKygq6VfulCS7Mmf00kZZRdaXim6V/ShnB4AczAkEAonoppEgQprjP+sUn33tf3xd6r9Cpa5Yo5WjZHQSKM9n0AtWxVAjhwaA0yyCou6EDUgInR/T5zfHFNFbuw736JQJAB49KMNoT+z+ElCbtkPOtL6nzZ8f84UrnvBZxDHzyql/kwW8KQIgOTyOYBOMM3pOMHIcqNNfAt82XchZ0VurlnQJBALmW42kRMNA0dR5zD5OBt5LDFux5Qiq9jus6dfcqF8LE4oH43WO/9mt987h7SyKngBiF+7KgH8qJYECdDifODks=-----END PRIVATE KEY-----');/**公钥*/define('RSA_PUBLIC', '-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwRu9ANZ3OwzbgoszQxuF5MSUBsBgYGX0KQ8xO+Qdd2cmrkw5QljcXdOAhKNYZbBEKxd8RmWVKF81ZEQgqIRKwcNEOvv4mJTSfG0PJHXZj+racvWqSVEVl0IgglU+RpJ/W1pBNFzBwN6jW74eyof9epxUoNmwSIThRcy5XIQ/P5QIDAQAB-----END PUBLIC KEY-----');class Test1 extends Base{ /** * 验证登录 * */ protected $uid; public function __construct() { if (is_numeric(parent::__construct())) { $this-&gt;uid = parent::__construct(); } else { echo parent::__construct(); exit; } } //意见反馈提交 public function index() { if (parent::getMethod() != 'true') { echo parent::getMethod(); exit; } $uid = $this-&gt;uid; $orderId = input('get.orderId'); $private_key = openssl_pkey_get_private(RSA_PRIVATE); if (!$private_key) { die('私钥不可用'); } $return_de = openssl_private_decrypt(base64_decode(base64_decode($orderId)), $decrypted, $private_key); if (!$return_de) { return('解密失败,请检查RSA秘钥---------'.$orderId); } $arr = json_decode($decrypted,true); return jsonReturnApi('操作失败', -1, $arr); }} Python1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import base64from hashlib import md5from Crypto.Cipher import AESfrom Crypto import Randomfrom Crypto.PublicKey import RSA# # AES加密的密钥（长度32个字节）# key = md5(b'1qaz2wsx').hexdigest()# # AES加密的初始向量（随机生成）# iv = Random.new().read(AES.block_size)def main(): \"\"\"主函数\"\"\" # 生成密钥对 key_pair = RSA.generate(1024) # 导入公钥 pub_key = RSA.importKey(key_pair.publickey().exportKey()) # 导入私钥 pri_key = RSA.importKey(key_pair.exportKey()) message1 = 'hello, world!' # 加密数据 data = pub_key.encrypt(message1.encode(), None) # 对加密数据进行BASE64编码 message2 = base64.b64encode(data[0]) print(message2) # 对加密数据进行BASE64解码 data = base64.b64decode(message2) # 解密数据 message3 = pri_key.decrypt(data) print(message3.decode()) # # AES - 对称加密 # str1 = '我爱你们！' # cipher = AES.new(key, AES.MODE_CFB, iv) # # 加密 # str2 = cipher.encrypt(str1) # print(str2) # # 解密 # cipher = AES.new(key, AES.MODE_CFB, iv) # str3 = cipher.decrypt(str2) # print(str3.decode())if __name__ == '__main__': main()","link":"/2019/05/05/Django-RESTfulAPI-安全设计/"},{"title":"Apache学习","text":"Mac自带apache服务器12345sudo apachectl start #开启apache sudo apachectl restart #重启apache sudo apachectl stop #关闭apache mac默认目录/Library/WebServer/Documents/ 12345678910cd /etc/apache2 #切换工作目录下：sudo cp httpd.conf httpd.conf.bak #备份文件，只需要执行一次：sudo cp httpd.conf.bak httpd.conf #如果操作出现错误！可以使用命令，恢复备份的 httpd.conf 文件：sudo vim httpd.conf #用vim编辑httpd.conf文件，httpd.conf文件时Apache的配置文件：#搜索/DocumentRoot，找到对应位置将路径改为自己创建的文件文件夹的路径#之后找到Options FollowSymLinks：修改为Options Indexes FollowSymLinks，在两个单词间添加一个Indexes单词。#接下来查找php，:/php 将代码前面的＃去掉。最后:wq保存并退出cd /etc #切换工作目录：sudo cp php.ini.default php.ini#拷贝php.ini文件：sudo apachectl -k restart #重启","link":"/2017/01/02/Apache学习/"},{"title":"Django知识点概述","text":"Django知识点概述 HTTPRequest对象的属性和方法： method - 获取请求方法 path / get_full_path() - 获取请求路径/带查询字符串的路径 scheme / is_secure() / get_host() / get_port() - 获取请求的协议/主机/端口 META / COOKIES - 获取请求头/Cookie信息 GET / POST / FILES - 获取GET或POST请求参数/上传的文件 get_signed_cookie() - 获取带签名的Cookie is_ajax() - 是不是Ajax异步请求 body / content_type / encoding - 获取请求的消息体（bytes流）/MIME类型/编码 中间件添加的属性： session / user / site HttpResponse对象的属性和方法： set_cookie() / set_signed_cookie() / delete_cookie() - 添加/删除Cookie __setitem__ / __getitem__ / __delitem__ - 添加/获取/删除响应头 charset / content / status_code - 响应的字符集/消息体（bytes流）/状态码 1xx：请求已经收到，继续处理 2xx（成功）：请求已经成功收到、理解和接收。 3xx（重定向）：为完成请求要继续执行后续的操作。 4xx（客户端错误）：请求不正确或不能够被受理。 5xx（服务器错误）：服务器处理请求失败。 JsonResponse（HttpResponse的子类型）对象 123456789101112131415&gt;&gt;&gt; from django.http import HttpResponse, JsonResponse&gt;&gt;&gt;&gt;&gt;&gt; response = JsonResponse({'foo': 'bar'})&gt;&gt;&gt; response.content&gt;&gt;&gt;&gt;&gt;&gt; response = JsonResponse([1, 2, 3], safe=False)&gt;&gt;&gt; response.content&gt;&gt;&gt;&gt;&gt;&gt; response = HttpResponse(b'...')&gt;&gt;&gt; response['cotent-type'] = 'application/pdf';&gt;&gt;&gt; response['content-disposition'] = 'inline; filename=\"xyz.pdf\"'&gt;&gt;&gt; response['content-disposition'] = 'attachment; filename=\"xyz.pdf\"'&gt;&gt;&gt;&gt;&gt;&gt; response.set_signed_cookie('foo', 'bar', salt='')&gt;&gt;&gt; response.status_code = 200 数据模型(Model)问题1：关系型数据库表的设计应该注意哪些问题（范式理论和逆范式）？如何通过表来创建模型类（反向工程）？如何通过模型类来创建表（正向工程）？ 1234python manage.py makemigrations &lt;appname&gt;python manage.py migratepython manage.py inspectdb &gt; &lt;appname&gt;/models.py 问题2：关系型数据库中数据完整性指的是什么？什么时候需要牺牲数据完整性？（实体完整性/参照完整性/域完整性） 问题3：ORM是什么以及解决了什么问题？（对象模型-关系模型双向转换） Field及其子类的属性： 通用选项： db_column / db_tablespace null / blank / default primary_key db_index / unqiue choices / help_text / error_message / editable / hidden 其他选项： CharField: max_length DateField: auto_now / auto_now_add DecimalField: max_digits / decimal_places FileField: storage / upload_to ImageField: height_field / width_field ForeignKey的属性： 重要属性： db_constraint（提升性能或者数据分片的情况可能需要设置为False） on_delete CASCADE：级联删除。 PROTECT：抛出ProtectedError异常，阻止删除引用的对象。 SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。 SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。 related_name 12345678910class Dept(models.Model): passclass Emp(models.Model): dept = models.ForeignKey(related_name='+', ...) Dept.objects.get(no=10).emp_set.all()Emp.objects.filter(dept__no=10) 说明：related_name设置为'+'，可以防止一对多外键关联从“一”的一方查询“多”的一方。 其他属性： to_field / limit_choices_to / swappable Model的属性和方法 objects / pk save() / delete() clean() / validate_unique() / full_clean() QuerySet的方法 get() / all() / values() 说明：values()返回的QuerySet中不是模型对象而是字典 count() / order_by() / exists() / reverse() filter() / exclude() exact / iexact：精确匹配/忽略大小写的精确匹配查询 contains / icontains / startswith / istartswith / endswith / iendswith：基于like的模糊查询 in：集合运算 gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算 range：指定范围查询（SQL中的between…and…） year / month / day / week_day / hour / minute / second：查询时间日期 isnull：查询空值（True）或非空值（False） search：基于全文索引的全文检索 regex / iregex：基于正则表达式的模糊匹配查询 aggregate() / annotate() Avg / Count / Sum / Max / Min 1234&gt;&gt;&gt; from django.db.models import Avg&gt;&gt;&gt; Emp.objects.aggregate(avg_sal=Avg('sal'))(0.001) SELECT AVG(`TbEmp`.`sal`) AS `avg_sal` FROM `TbEmp`; args=(){'avg_sal': 3521.4286} 123&gt;&gt;&gt; Emp.objects.values('dept').annotate(total=Count('dept'))(0.001) SELECT `TbEmp`.`dno`, COUNT(`TbEmp`.`dno`) AS `total` FROM `TbEmp` GROUP BY `TbEmp`.`dno` ORDER BY NULL LIMIT 21; args=()&lt;QuerySet [{'dept': 10, 'total': 4}, {'dept': 20, 'total': 7}, {'dept': 30, 'total': 3}] first() / last() 说明：调用first()方法相当于用[0]对QuerySet进行切片。 only() / defer() 123456&gt;&gt;&gt; Emp.objects.filter(pk=7800).only('name', 'sal')(0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`ename`, `TbEmp`.`sal` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,)&lt;QuerySet [&lt;Emp: Emp object (7800)&gt;]&gt;&gt;&gt;&gt; Emp.objects.filter(pk=7800).defer('name', 'sal')(0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`job`, `TbEmp`.`mgr`, `TbEmp`.`comm`, `TbEmp`.`dno` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,)&lt;QuerySet [&lt;Emp: Emp object (7800)&gt;]&gt; create() / update() / raw() 12345&gt;&gt;&gt; Emp.objects.filter(dept__no=20).update(sal=F('sal') + 100)(0.011) UPDATE `TbEmp` SET `sal` = (`TbEmp`.`sal` + 100) WHERE `TbEmp`.`dno` = 20; args=(100, 20)&gt;&gt;&gt;&gt;&gt;&gt; Emp.objects.raw('select empno, ename, job from TbEmp where dno=10')&lt;RawQuerySet: select empno, ename, job from TbEmp where dno=10&gt; Q对象和F对象 说明：Q对象主要用来解决多条件组合的复杂查询；F对象主要用于更新数据。 123456&gt;&gt;&gt; from django.db.models import Q&gt;&gt;&gt; Emp.objects.filter(... Q(name__startswith='张'),... Q(sal__lte=5000) | Q(comm__gte=1000)... ) # 查询名字以“张”开头且工资小于等于5000或补贴大于等于1000的员工&lt;QuerySet [&lt;Emp: 张三丰&gt;]&gt; 1234&gt;&gt;&gt; from backend.models import Emp, Dept&gt;&gt;&gt; emps = Emp.objects.filter(dept__no=20)&gt;&gt;&gt; from django.db.models import F&gt;&gt;&gt; emps.update(sal=F('sal') + 100) 原生SQL查询 1234567from django.db import connections with connections['...'].cursor() as cursor: cursor.execute(\"UPDATE TbEmp SET sal=sal+10 WHERE dno=30\") cursor.execute(\"SELECT ename, job FROM TbEmp WHERE dno=10\") row = cursor.fetchall() 模型管理器 12345678class BookManager(models.Manager): def title_count(self, keyword): return self.filter(title__icontains=keyword).count() class Book(models.Model): objects = BookManager()","link":"/2018/02/20/Django知识点概述/"},{"title":"Django入门","text":"Django mysql配置1234567891011底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclient底层使用 mysqlclientDATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'xxx', 'USER': 'xxx', 'PASSWORD':'xxx', 'HOST': 'localhost', 'PORT': '3306', }} VSCode 运行Django123456789101112131415DEBUG 选择python:Django{ \"name\": \"Python: Django\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/manage.py\", \"console\": \"integratedTerminal\", \"args\": [ \"runserver\", \"8080\",#添加端口号 \"--noreload\", \"--nothreading\" ], \"django\": true}, Django自动生成对象模型12345678910自动生成models模型文件 Python3 manage.py inspectdb 这样就可以在控制台的命令行中看到数据库的模型文件了把模型文件导入到app中 创建一个app python3 manage.py inspectdb &gt; app/models.py 生成单张表python3 manage.py inspectdb api_blog_subject&gt; cms/models/blogSubject.py Django框架使用-生成数据库表12345python3 manage.py makemigrations #会检查数据库定义的代码是否正确.python3 manage.py migratepython3 manage.py flush #清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）#清空数据库（此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。）python3 manage.py createsuperuser #创建超级管理员 Django setting中 time zone和language code设置中文的问题123456将language code设置为'zh-cn'后每次启动server都提示error，说找不到zh-cn的language code。最后发现改成'zh-hans'即可Django1.9以后language code 'zh-cn'就被丢弃了，使用'zh-hans'代替。TIME_ZONE = 'Asia/Shanghai'LANGUAGE_CODE = 'zh-hans'","link":"/2018/01/13/Django入门/"},{"title":"Django-API插件类","text":"Response的插件类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455\"\"\"定义一个插件类，\"\"\"from django.http import JsonResponse, HttpResponseimport json# 自定义状态码class HttpCode(object): # 正常登陆 ok = 200 # 参数错误 paramserror = 400 # 权限错误 unauth = 401 # 方法错误 methoderror = 405 # 服务器内部错误 servererror = 500# 定义统一的 json 字符串返回格式def result(code=HttpCode.ok, message=\"\", data={}, kwargs=None): json_dict = {} safe = True if not isinstance(data, dict): json_dict = {\"code\": code, \"message\": message, \"data\": list(data)} safe = False else: json_dict = {\"code\": code, \"message\": message, \"data\": data} # print('返回值'+json_dict) return JsonResponse(json_dict,safe=safe)def ok(data={},message=\"\"): return result(code=0, message=message, data=data)# 参数错误def params_error(message=\"\", data={}): return result(code=1, message=message, data=data)# 权限错误def unauth(message=\"\", data={}): return result(code=4, message=message, data=data)# 方法错误def method_error(message=\"\", data={}): return result(code=2, message=message, data=data)# 服务器内部错误def server_error(message=\"\", data={}): return result(code=3, message=message, data=data) request的插件类1234567891011121314151617181920212223242526272829def requestIsGet(view): def decorator( request, *args, **kwargs): print('自定义装饰器被调用了') print('请求路径%s' % request.path) if request.method != 'GET': return reqMethodError(0) return view(request, *args, **kwargs) return decoratordef requestIsPost(view): def decorator( request, *args, **kwargs): print('自定义装饰器被调用了') print('请求路径%s' % request.path) if request.method != 'POST': return reqMethodError(0) return view(request, *args, **kwargs) return decoratordef reqMethodError(type): msg = '' if type == 0 : msg = '请求方式错误，应该为Get请求' elif type == 1 : msg = '请求方式错误，应该为Get请求' return resultApi.method_error(msg)def page_not_found(request): print ('404') return render(request, 'blogs/404.html') 插件类的使用1234@requestIsGetdef index(request): data = {} return resultApi.ok(data)","link":"/2019/03/26/Django-API插件类/"},{"title":"Django知识点概述2","text":"视图函数(Controller)如何设计视图函数 用户的每个操作（用户故事）对应一个视图函数。 每个视图函数可以构成一个事务边界。 事务的ACID特性。 原子性（Atomicity）：事务中各项的操作要么全做要么全不做； 一致性（Consistentcy）：事务前后系统的状态是一致的； 隔离性（Isolation）：并发执行的事务无法看到彼此的中间状态； 持久性（Duration）：事务完成后所做的改动都会被持久化。 事务隔离级别 - 设置事务隔离级别是为了数据库底层依据事务隔离级别为数据加上适当的锁。如果需要保证数据的强一致性，那么关系型数据库仍然是唯一的也是最好的选择，因为关系型数据库可以通过锁机制来保护数据。事务隔离级别从低到高依次是：Read Uncommitted（读未提交）、Read Committed（读提交）、Repeatable Read（可重复读）、Serializable（串行化）。事务隔离级别越高，数据并发访问的问题越少，但是性能越差；事务隔离级别越低，数据并发访问的问题越多，但是性能越好。 数据并发访问会产生5种问题（请参考我的《Java面试题全集（上）》第80题对该问题的讲解）： 第1类丢失更新（A事务撤销覆盖B事务更新的数据）和第2类丢失更新（A事务提交覆盖B事务更新的数据）。 脏读（读脏数据）：一个事务读取到其他尚未提交的事务的数据。 不可重复读： 一个事务在读取它的查询结果时，被另一个事务更新了它的查询记录导致无法读到数据。 幻读：一个事务在读取它的查询结果时，发现读到了被另一个事务提交的新数据。 123456-- 设置全局默认的事务隔离级别set global transaction isolation level repeatable read;-- 设置当前会话的事务隔离级别set session transaction isolation level read committed;-- 查询当前会话的事务隔离级别select @@tx_isolation; Django中的事务控制。 给每个请求绑定事务环境（反模式）。 1ATOMIC_REQUESTS = True 使用事务装饰器（简单易用） - 粗粒度（控制不够精细）。 12@transaction.non_atomic_requests@transaction.atomic 使用上下文语法（细粒度 - 事务控制的范围更加精准）。 12with transaction.atomic(): pass 关闭自动提交使用手动提交。 1AUTOCOMMIT = False 12transaction.commit()transaction.rollback() URL配置 可以让部分URL只在调试模式下生效。 12345678from django.conf import settings urlpatterns = [...] if settings.DEBUG:urlpatterns += [ ... ] 可以使用命名捕获组捕获路径参数。 12url(r'api/code/(?P&lt;mobile&gt;1[3-9]\\d{9})'),path('api/code/&lt;str:mobile&gt;'), URL配置不关心请求使用的方法（一个视图函数可以处理不同的请求方式）。 如果使用url函数捕获的路径参数都是字符串，path函数可以指定路径参数类型。 可以使用include函数引入其他URL配置，捕获的参数会向下传递。 在url和path函数甚至是include函数中都可以用字典向视图传入额外的参数，如果参数与捕获的参数同名，则使用字典中的参数。 可以用reverse函数实现URL的逆向解析（从名字解析出URL），在模板中也可以用url实现同样的操作。 1234path('', views.index, name='index') return redirect(reverse('index'))return redirect('index') 模板(View)后端渲染 模板的配置和渲染函数。 123456789101112131415TEMPLATES = [{ 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates'), ], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], },},] 1resp = render(request, 'index.html', {'foo': ...}) 模板遇到变量名的查找顺序。 字典查找（如：foo['bar']） 属性查找（如：foo.bar） 方法调用（如：foo.bar()） 方法不能有必须传值的参数 在模板中不能够给方法传参 如果方法的alters_data被设置为True则不能调用该方法（避免误操作的风险），模型对象动态生成的delete()和save()方法都设定了alters_data = True。 列表索引查找（如：foo[0]） 模板标签的使用。 if / else / endif for / endfor ifequal / endifequal / ifnotequal / endifnotequal / comment / endcomment 过滤器的使用。 lower / upper / first / last / truncatewords / date/ time / length / pluralize / center / ljust / rjust / cut / urlencode / default_if_none / filesizeformat / join / slice / slugify 模板的包含和继承。 include / block extends 模板加载器（后面优化部分会讲到）。 文件系统加载器 1234TEMPLATES = [{ 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')],}] 应用目录加载器 1234TEMPLATES = [{ 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True,}] 前端渲染 前端模板引擎：Handlebars / Mustache。 前端MV*框架。 MVC - AngularJS MVVM(Model-View-ViewModel) - Vue.js 其他视图 MIME（多用途Internet邮件扩展）类型 - 告知浏览器传输的数据类型。 Content-Type 说明 application/json JSON（JavaScript Object Notation） application/pdf PDF（Portable Document Format） audio/mpeg MP3或其他MPEG音频文件 audio/vnd.wave WAV音频文件 image/gif GIF图像文件 image/jpeg JPEG图像文件 image/png PNG图像文件 text/html HTML文件 text/xml XML video/mp4 MP4视频文件 video/quicktime QuickTime视频文件 如何处置生成的内容（inline / attachment）。 1234567&gt;&gt;&gt; from urllib.parse import quote&gt;&gt;&gt;&gt;&gt;&gt; response['content-type'] = 'application/pdf'&gt;&gt;&gt; filename = quote('Python语言规范.pdf')&gt;&gt;&gt; filename'Python%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf'&gt;&gt;&gt; response['content-disposition'] = f'attachment; filename=\"{filename}\"' 提醒：URL以及请求和响应头中的中文都应该处理成百分号编码。 生成CSV / Excel / PDF / 统计报表。 向浏览器传输二进制数据。 12345buffer = ByteIO() resp = HttpResponse(content_type='...')resp['Content-Disposition'] = 'attachment; filename=\"...\"'resp.write(buffer.getvalue()) 123456789101112131415161718192021222324252627282930313233343536373839def get_style(name, color=0, bold=False, italic=False): style = xlwt.XFStyle() font = xlwt.Font() font.name = name font.colour_index = color font.bold = bold font.italic = italic style.font = font return style def export_emp_excel(request): # 创建Excel工作簿(使用三方库xlwt) workbook = xlwt.Workbook() # 向工作簿中添加工作表 sheet = workbook.add_sheet('员工详细信息') # 设置表头 titles = ['编号', '姓名', '主管', '职位', '工资', '部门名称'] for col, title in enumerate(titles): sheet.write(0, col, title, get_style('HanziPenSC-W3', 2, True)) # 使用Django的ORM框架查询员工数据 emps = Emp.objects.all().select_related('dept').select_related('mgr') cols = ['no', 'name', 'mgr', 'job', 'sal', 'dept'] # 通过嵌套的循环将员工表的数据写入Excel工作表的单元格 for row, emp in enumerate(emps): for col, prop in enumerate(cols): val = getattr(emp, prop, '') if isinstance(val, (Dept, Emp)): val = val.name sheet.write(row + 1, col, val) # 将Excel文件的二进制数据写入内存 buffer = BytesIO() workbook.save(buffer) # 通过HttpResponse对象向浏览器输出Excel文件 resp = HttpResponse(buffer.getvalue()) resp['content-type'] = 'application/msexcel' # 如果文件名有中文需要处理成百分号编码 resp['content-disposition'] = 'attachment; filename=\"detail.xls\"' return resp 大文件的流式处理：StreamingHttpResponse。 12345678910def download_file(request): file_stream = open('...', 'rb') # 如果文件的二进制数据较大则最好用迭代器进行处理避免过多的占用服务器内存 file_iter = iter(lambda: file_stream.read(4096), b'') resp = StreamingHttpResponse(file_iter) # 中文文件名要处理成百分号编码 filename = quote('...', 'utf-8') resp['Content-Type'] = '...' resp['Content-Disposition'] = f'attachment; filename=\"{filename}\"' return resp 说明：如果需要生成PDF文件，可以需要安装reportlab。另外，使用StreamingHttpResponse只能减少内存的开销，但是如果下载一个大文件会导致一个请求长时间占用服务器资源，比较好的做法还是把报表提前生成好（可以考虑使用定时任务），放在静态资源服务器或者是云存储服务器上以访问静态资源的方式访问。 ECharts或Chart.js。 思路：后端只提供JSON格式的数据，前端JavaScript渲染生成图表。 12345678910111213def get_charts_data(request): \"\"\"获取统计图表JSON数据\"\"\" names = [] totals = [] # 通过connections获取指定数据库连接并创建游标对象 with connections['backend'].cursor() as cursor: # 在使用ORM框架时可以使用对象管理器的aggregate()和annotate()方法实现分组和聚合函数查询 # 执行原生SQL查询(如果ORM框架不能满足业务或性能需求) cursor.execute('select dname, total from vw_dept_emp') for row in cursor.fetchall(): names.append(row[0]) totals.append(row[1]) return JsonResponse({'names': names, 'totals': totals}) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;统计图表&lt;/title&gt; &lt;style&gt; #main { width: 600px; height: 400px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\"&gt;&lt;/div&gt; &lt;script src=\"https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var myChart = echarts.init($('#main')[0]); $.ajax({ 'url': 'charts_data', 'type': 'get', 'data': {}, 'dataType': 'json', 'success': function(json) { var option = { title: { text: '员工分布统计图' }, tooltip: {}, legend: { data:['人数'] }, xAxis: { data: json.names }, yAxis: {}, series: [{ name: '人数', type: 'bar', data: json.totals }] }; myChart.setOption(option); }, 'error': function() {} }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间件问题1：中间件背后的设计理念是什么？（分离横切关注功能/拦截过滤器模式） 问题2：中间件有哪些不同的实现方式？（参考下面的代码） 问题3：描述Django内置的中间件及其执行顺序。（推荐阅读：Django官方文档 - 中间件 - 中间件顺序） 激活中间件12345678910MIDDLEWARE = ['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware','django.middleware.csrf.CsrfViewMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware','django.contrib.messages.middleware.MessageMiddleware','django.middleware.clickjacking.XFrameOptionsMiddleware','common.middlewares.block_sms_middleware',] 自定义中间件123456789def simple_middleware(get_response): def middleware(request, *args, **kwargs): response = get_response(request, *args, **kwargs) return response return middleware 12345678910class MyMiddleware(object): def __init__(self, get_response):self.get_response = get_response def __call__(self, request): response = self.get_response(request) return response 12345678910111213141516171819class MyMiddleware(object): def __init__(self):pass def process_request(request):pass def process_view(request, view_func, view_args, view_kwargs):pass def process_template_response(request, response):pass def process_response(request, response):pass def process_exception(request, exception):pass 内置中间件 CommonMiddleware - 基础设置中间件 DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器） APPEND_SLASH - 是否追加/ USE_ETAG - 浏览器缓存相关 SecurityMiddleware - 安全相关中间件 SECURE_HSTS_SECONDS - 强制使用HTTPS的时间 SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆盖子域名 SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型 SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器 SECURE_SSL_REDIRECT - 是否重定向到HTTPS连接 SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS SessionMiddleware - 会话中间件 CsrfViewMiddleware - 防范跨站身份伪造中间件 XFrameOptionsMiddleware - 防范点击劫持攻击中间件 表单 用法：通常不要用来生成页面上的表单控件（耦合度太高不容易定制），主要用来验证数据。 Form的属性和方法： is_valid() / is_multipart() errors / fields / is_bound / changed_data / cleaned_data add_error() / has_errors() / non_field_errors() clean() Form.errors的方法： as_data() / as_json() / get_json_data() 问题1：Django中的Form和ModelForm有什么作用？（通常不用来生成表单主要用来验证数据） 问题2：表单上传文件时应该注意哪些问题？（表单的设置、多文件上传、图片预览（FileReader）、Ajax上传文件、上传后的文件如何存储、调用云存储（如阿里云OSS、七牛云、LeanCloud等）） 123456&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"...\" multiple&gt;&lt;input type=\"file\" name=\"foo\"&gt;&lt;input type=\"file\" name=\"foo\"&gt;&lt;input type=\"file\" name=\"foo\"&gt;&lt;/form&gt; 说明：上传图片文件的预览效果可以通过HTML5的FileReader来实现。 说明：使用云存储通常是比自己配置分布式文件系统这种方式更靠谱的做法，而且云存储通常成本并不太高，不仅如此大多数云存储还提供了如图片剪裁、生成水印、视频转码、CDN等服务。如果要自己做上传的视频文件转码，需要安装三方库ffmpeg，在程序中调用该三方库可以实现转码。 Cookie和Session问题1：使用Cookie能解决什么问题？（用户跟踪，解决HTTP协议无状态问题） URL重写 1http://www.abc.com/path/resource?foo=bar 隐藏域（隐式表单域）- 埋点 12345&lt;form action=\"\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"foo\" value=\"bar\"&gt; &lt;/form&gt; Cookie - 浏览器中的临时文件（文本文件）- BASE64 问题2：Cookie和Session之间关系是什么？（Session的标识通过Cookie保存和传输） Session的配置 Session对应的中间件：django.contrib.sessions.middleware.SessionMiddleware。 Session引擎。 基于数据库（默认方式） 123INSTALLED_APPS = [ 'django.contrib.sessions',] 基于缓存（推荐使用） 12SESSION_ENGINE = 'django.contrib.sessions.backends.cache'SESSION_CACHE_ALIAS = 'session' 基于文件（基本不考虑） 基于Cookie（不靠谱） 1SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' Cookie相关的配置。 123456SESSION_COOKIE_NAME = 'djang_session_id'SESSION_COOKIE_AGE = 1209600# 如果设置为True，Cookie就是基于浏览器窗口的Cookie，不会持久化SESSION_EXPIRE_AT_BROWSER_CLOSE = False SESSION_SAVE_EVERY_REQUEST = FalseSESSION_COOKIE_HTTPONLY = True session的属性和方法。 session_key / session_data / expire_date __getitem__ / __setitem__ / __delitem__ / __contains__ set_expiry() / get_expiry_age() / get_expiry_date() - 设置/获取会话超期时间 flush() - 销毁会话 set_test_cookie() / test_cookie_worked() / delete_test_cookie() - 测试浏览器是否支持Cookie（提示用户如果浏览器禁用Cookie可能会影响网站的使用） session的序列化。 1SESSION_SERIALIZER = 'django.contrib.sessions.serializers.JSONSerializer' JSONSerializer（1.6及以后默认）- 如果想将自定义的对象放到session中，会遇到“Object of type ‘XXX’ is not JSON serializable”的问题（如果配置使用Redis保存Session，django-redis使用了Pickle序列化，这个问题就不存在了）。 PickleSerializer（1.6以前的默认）- 因为安全问题不推荐使用，但是只要不去反序列化用户构造的恶意的Payload其实也没有什么风险。关于这种方式的安全漏洞，可以参考《Python Pickle的任意代码执行漏洞实践和Payload构造》一文或《软件架构-Python语言实现》上关于这个问题的讲解。 说明：如果使用了django_redis整合Redis作为session的存储引擎，那么由于django_redis又封装了一个PickleSerializer来提供序列化，所以不会存在上述的问题，且Redis中保存的value是pickle序列化之后的结果。","link":"/2018/04/25/Django知识点概述2/"},{"title":"Django知识点概述3","text":"缓存配置缓存12345678910111213141516CACHES = {# 默认缓存'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://1.2.3.4:6379/0', ], 'KEY_PREFIX': 'teamproject', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': { 'max_connections': 1000, }, 'PASSWORD': '1qaz2wsx', }}, 123456789101112131415# 页面缓存'page': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://1.2.3.4:6379/1', ], 'KEY_PREFIX': 'teamproject:page', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': { 'max_connections': 500, }, 'PASSWORD': '1qaz2wsx', }}, 12345678910111213141516# 会话缓存'session': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://1.2.3.4:6379/2', ], 'KEY_PREFIX': 'teamproject:session', 'TIMEOUT': 1209600, 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': { 'max_connections': 2000, }, 'PASSWORD': '1qaz2wsx', }}, 12345678910111213141516# 接口数据缓存'api': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://1.2.3.4:6379/3', ], 'KEY_PREFIX': 'teamproject:api', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': { 'max_connections': 500, }, 'PASSWORD': '1qaz2wsx', }},} 说明：通过Redis底层提供的多个数据库来隔离缓存数据有助于缓存数据的管理。如果配置了Redis的主从复制（读写分离），LOCATION列表中可以配置多个Redis连接，第一个被视为master用来进行写操作，后面的被视为slave用来进行读操作。 全站缓存1234567891011MIDDLEWARE_CLASSES = ['django.middleware.cache.UpdateCacheMiddleware',...'django.middleware.common.CommonMiddleware',...'django.middleware.cache.FetchFromCacheMiddleware',]CACHE_MIDDLEWARE_ALIAS = 'default'CACHE_MIDDLEWARE_SECONDS = 300CACHE_MIDDLEWARE_KEY_PREFIX = 'djang:cache' 视图层缓存12345678from django.views.decorators.cache import cache_pagefrom django.views.decorators.vary import vary_on_cookie@cache_page(timeout=60 * 15, cache='page')@vary_on_cookiedef my_view(request):pass 12345from django.views.decorators.cache import cache_pageurlpatterns = [url(r'^foo/([0-9]{1,2})/$', cache_page(60 * 15)(my_view)),] 其他内容 模板片段缓存。 load cache cache / endcache 使用底层API访问缓存。 12345&gt;&gt;&gt; from django.core.cache import cache&gt;&gt;&gt;&gt;&gt;&gt; cache.set('my_key', 'hello, world!', 30)&gt;&gt;&gt; cache.get('my_key')&gt;&gt;&gt; cache.clear() 12345678&gt;&gt;&gt; from django.core.cache import caches&gt;&gt;&gt; cache1 = caches['page']&gt;&gt;&gt; cache2 = caches['page']&gt;&gt;&gt; cache1 is cache2True&gt;&gt;&gt; cache3 = caches['session']&gt;&gt;&gt; cache2 is cache3False 1234&gt;&gt;&gt; from django_redis import get_redis_connection&gt;&gt;&gt;&gt;&gt;&gt; redis_client = get_redis_connection()&gt;&gt;&gt; redis_client.hgetall() 日志日志级别NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; FATAL 日志配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455LOGGING = {'version': 1,'disable_existing_loggers': False,# 配置日志格式化器'formatters': { 'simple': { 'format': '%(asctime)s %(module)s.%(funcName)s: %(message)s', 'datefmt': '%Y-%m-%d %H:%M:%S', }, 'verbose': { 'format': '%(asctime)s %(levelname)s [%(process)d-%(threadName)s] ' '%(module)s.%(funcName)s line %(lineno)d: %(message)s', 'datefmt': '%Y-%m-%d %H:%M:%S', }},# 配置日志过滤器'filters': { 'require_debug_true': { '()': 'django.utils.log.RequireDebugTrue', },},# 配置日志处理器'handlers': { 'console': { 'class': 'logging.StreamHandler', 'level': 'DEBUG', 'filters': ['require_debug_true'], 'formatter': 'simple', }, 'file1': { 'class': 'logging.handlers.TimedRotatingFileHandler', 'filename': 'access.log', 'when': 'W0', 'backupCount': 12, 'formatter': 'simple', 'level': 'INFO', }, 'file2': { 'class': 'logging.handlers.TimedRotatingFileHandler', 'filename': 'error.log', 'when': 'D', 'backupCount': 31, 'formatter': 'verbose', 'level': 'WARNING', },},# 配置日志器'loggers': { 'django': { 'handlers': ['console', 'file1', 'file2'], 'propagate': True, 'level': 'DEBUG', },}} 日志配置官方示例。 日志分析 Linux相关命令：head、tail、grep、awk、uniq、sort 1tail -10000 access.log | awk '{print $1}' | uniq -c | sort -r 实时日志文件分析：Python + 正则表达式 + Crontab 《Python日志分析工具》。 《集中式日志系统ELK》。 ElasticSearch：搜索引擎，实现全文检索。 Logstash：负责从指定节点收集日志。 Kibana：日志可视化工具。 大数据日志处理：Flume+Kafka日志采集、Storm / Spark实时数据处理、Impala实时查询。","link":"/2018/04/26/Django知识点概述3/"},{"title":"Django知识点概述4","text":"RESTful问题1：RESTful架构到底解决了什么问题？（URL具有自描述性、资源表述与视图的解耦和、互操作性利用构建微服务以及集成第三方系统、无状态性提高水平扩展能力） 问题2：项目在使用RESTful架构时有没有遇到一些问题或隐患？（对资源访问的限制、资源从属关系检查、避免泄露业务信息、防范可能的攻击） 补充：下面的几个和安全性相关的响应头在前面讲中间件的时候提到过的。 X-Frame-Options: DENY X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block; Strict­-Transport-­Security: max-age=31536000; 问题3：如何保护API中的敏感信息以及防范重放攻击？（摘要和令牌） 推荐阅读：《如何有效防止API的重放攻击》。 使用djangorestframework安装djangorestfrmework（为了描述方便，以下统一简称为drf）。 1pip install djangorestframework 配置drf。 123456789101112131415161718192021222324252627282930INSTALLED_APPS = [ 'rest_framework', ]REST_FRAMEWORK = {# 配置默认页面大小'PAGE_SIZE': 10,# 配置默认的分页类'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',# 配置异常处理器# 'EXCEPTION_HANDLER': 'api.exceptions.exception_handler',# 配置默认解析器# 'DEFAULT_PARSER_CLASSES': (# 'rest_framework.parsers.JSONParser',# 'rest_framework.parsers.FormParser',# 'rest_framework.parsers.MultiPartParser',# ),# 配置默认限流类# 'DEFAULT_THROTTLE_CLASSES': (),# 配置默认授权类# 'DEFAULT_PERMISSION_CLASSES': (# 'rest_framework.permissions.IsAuthenticated',# ),# 配置默认认证类# 'DEFAULT_AUTHENTICATION_CLASSES': (# 'rest_framework_jwt.authentication.JSONWebTokenAuthentication',# ),} 编写序列化器123456789101112131415161718192021222324252627282930313233343536373839404142from rest_framework import serializersfrom rest_framework.serializers import ModelSerializerfrom common.models import District, HouseType, Estate, Agentclass DistrictSerializer(ModelSerializer):class Meta: model = District fields = ('distid', 'name')class HouseTypeSerializer(ModelSerializer):class Meta: model = HouseType fields = '__all__'class AgentSerializer(ModelSerializer):class Meta: model = Agent fields = ('agentid', 'name', 'tel', 'servstar', 'certificated')class EstateSerializer(ModelSerializer):district = serializers.SerializerMethodField()agents = serializers.SerializerMethodField()@staticmethoddef get_agents(estate): return AgentSerializer(estate.agents, many=True).data@staticmethoddef get_district(estate): return DistrictSerializer(estate.district).dataclass Meta: model = Estate fields = '__all__' 方法1：使用装饰器1234567891011121314@api_view(['GET'])@cache_page(timeout=None, cache='api')def provinces(request):queryset = District.objects.filter(parent__isnull=True)serializer = DistrictSerializer(queryset, many=True)return Response(serializer.data)@api_view(['GET'])@cache_page(timeout=300, cache='api')def cities(request, provid):queryset = District.objects.filter(parent__distid=provid)serializer = DistrictSerializer(queryset, many=True)return Response(serializer.data) 1234urlpatterns = [path('districts/', views.provinces, name='districts'),path('districts/&lt;int:provid&gt;/', views.cities, name='cities'),] 说明：上面使用了Django自带的视图装饰器（@cache_page）来实现对API接口返回数据的缓存。 方法2：使用APIView及其子类更好的复用代码，不要重“复发明轮子”。 123class HouseTypeApiView(CacheResponseMixin, ListAPIView):queryset = HouseType.objects.all()serializer_class = HouseTypeSerializer 123urlpatterns = [path('housetypes/', views.HouseTypeApiView.as_view(), name='housetypes'),] 说明：上面使用了drf_extensions提供的CacheResponseMixin混入类实现了对接口数据的缓存。如果重写了获取数据的方法，可以使用drf_extensions提供的@cache_response来实现对接口数据的缓存，也可以用自定义的函数来生成缓存中的key。当然还有一个选择就是通过Django提供的@method_decorator装饰器，将@cache_page装饰器处理为装饰方法的装饰器，这样也能提供使用缓存服务。 drf-extensions配置如下所示。 123456789# 配置DRF扩展来支持缓存API接口调用结果REST_FRAMEWORK_EXTENSIONS = {'DEFAULT_CACHE_RESPONSE_TIMEOUT': 300,'DEFAULT_USE_CACHE': 'default',# 配置默认缓存单个对象的key函数'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func',# 配置默认缓存对象列表的key函数'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func',} 方法3：使用ViewSet及其子类1234class HouseTypeViewSet(CacheResponseMixin, viewsets.ModelViewSet):queryset = HouseType.objects.all()serializer_class = HouseTypeSerializerpagination_class = None 1234router = DefaultRouter()router.register('housetypes', views.HouseTypeViewSet)urlpatterns += router.urls djangorestframework提供了基于Bootstrap定制的页面来显示接口返回的JSON数据，当然也可以使用POSTMAN这样的工具对API接口进行测试。 补充说明在这里顺便提一下跟前端相关的几个问题。 问题1：如何让浏览器能够发起DELETE/PUT/PATCH？ 12345&lt;form method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;/form&gt; 12if request.method == 'POST' and '_method' in request.POST:request.method = request.POST['_method'].upper() 1234567891011121314151617&lt;script&gt;$.ajax({ 'url': '/api/provinces', 'type': 'put', 'data': {}, 'dataType': 'json', 'success': function(json) { // Web = 标签(内容) + CSS(显示) + JS(行为) // JavaScript = ES + BOM + DOM // DOM操作实现页面的局部刷新 }, 'error': function() {}});$.getJSON('/api/provinces', function(json) { // DOM操作实现页面的局部刷新});&lt;/script&gt; 问题2：如何解决多个JavaScript库之间某个定义（如$函数）冲突的问题？ 123456789&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/abc.min.js\"&gt;&lt;/script&gt;&lt;script&gt;// $已经被后加载的JavaScript库占用了// 但是可以直接用绑定在window对象上的jQuery去代替$jQuery(function() { jQuery('#okBtn').on('click', function() {});});&lt;/script&gt; 123456789&lt;script src=\"js/abc.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;// 将$让出给其他的JavaScript库使用jQuery.noConflict();jQuery(function() { jQuery('#okBtn').on('click', function() {});});&lt;/script&gt; 问题3：jQuery对象与原生DOM对象之间如何转换？ 123456789&lt;button id=\"okBtn\"&gt;点我&lt;/button&gt;&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var btn = document.getElementById('okBtn'); // 原生JavaScript对象(使用相对麻烦)var $btn = $('#okBtn'); // jQuery对象(拥有更多的属性和方法而且没有浏览器兼容性问题)$btn.on('click', function() {});// $(btn)可以将原生JavaScript对象转成jQuery对象// $btn.get(0)或$btn[0]可以获得原生的JavaScript对象&lt;/script&gt; 过滤数据如果需要过滤数据（对数据接口设置筛选条件、排序条件等），可以使用django-filter三方库来实现。 1pip install django-filter 12345678910111213INSTALLED_APPS = [ 'django_filters',]REST_FRAMEWORK = { 'DEFAULT_FILTER_BACKENDS': ( 'django_filters.rest_framework.DjangoFilterBackend', 'rest_framework.filters.OrderingFilter',), } 123456789101112131415161718from django.utils.decorators import method_decoratorfrom django.views.decorators.cache import cache_pagefrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework.filters import OrderingFilterfrom rest_framework.generics import RetrieveAPIView, ListCreateAPIViewfrom api.serializers import EstateSerializerfrom common.models import Estate@method_decorator(decorator=cache_page(timeout=120, cache='api', key_prefix='estates'), name='get')class EstateView(RetrieveAPIView, ListCreateAPIView):queryset = Estate.objects.all().select_related('district').prefetch_related('agents')serializer_class = EstateSerializerfilter_backends = (DjangoFilterBackend, OrderingFilter)filter_fields = ('name', 'district')ordering = ('-hot', )ordering_fields = ('hot', 'estateid') 12345678910111213141516from django_filters import rest_framework as drffrom common.models import HouseInfoclass HouseInfoFilter(drf.FilterSet):\"\"\"自定义房源数据过滤器\"\"\"title = drf.CharFilter(lookup_expr='starts')dist = drf.NumberFilter(field_name='district')min_price = drf.NumberFilter(field_name='price', lookup_expr='gte')max_price = drf.NumberFilter(field_name='price', lookup_expr='lte')type = drf.NumberFilter()class Meta: model = HouseInfo fields = ('title', 'district', 'min_price', 'max_price', 'type') 123456789class HouseInfoViewSet(CacheResponseMixin, ReadOnlyModelViewSet):queryset = HouseInfo.objects.all() \\ .select_related('type', 'district', 'estate', 'agent') \\ .prefetch_related('tags').order_by('-pubdate')serializer_class = HouseInfoSerializerfilter_backends = (DjangoFilterBackend, OrderingFilter)filterset_class = HouseInfoFilterordering = ('price',)ordering_fields = ('price', 'area') 身份认证查看drf中APIView类的代码可以看出，drf默认的认证方案是 DEFAULT_AUTHENTICATION_CLASSES，如果修改authentication_classes就可以自行定制身份认证的方案。 `Pythonclass APIView(View):","link":"/2018/04/27/Django知识点概述4/"},{"title":"Django知识点概述5","text":"数据库 用ID生成器代替自增主键（性能更好、适用于分布式环境）。 自定义ID生成器 UUID 12345&gt;&gt;&gt; my_uuid = uuid.uuid1()&gt;&gt;&gt; my_uuidUUID('63f859d0-a03a-11e8-b0ad-60f81da8d840')&gt;&gt;&gt; my_uuid.hex'63f859d0a03a11e8b0ad60f81da8d840' 避免不必要的外键列上的约束（除非必须保证参照完整性），更不要使用触发器之类的机制。 使用索引来优化查询性能（索引放在要用于查询的字段上）。InnoDB用的是BTREE索引，使用&gt;、&lt;、&gt;=、&lt;=、BETWEEN或者LIKE ‘pattern’（pattern不以通配符开头）时都可以用到索引。因为建立索引需要额外的磁盘空间，而主键上是有默认的索引，所以主键要尽可能选择较短的数据类型来减少磁盘占用，提高索引的缓存效果。 1create index idx_goods_name on tb_goods (gname(10)); 1234-- 无法使用索引select * from tb_goods where gname like '%iPhone%';-- 可以使用索引select * from tb_goods where gname like 'iPhone%'; 1234# 无法使用索引Goods.objects.filter(name_icontains='iPhone')# 可以使用索引Goods.objects.filter(name__istartswith='iPhone'); 使用存储过程（存储在服务器端编译过的一组SQL语句）。 12345678910drop procedure if exists sp_avg_sal_by_dept; create procedure sp_avg_sal_by_dept(deptno integer, out avg_sal float)begin select avg(sal) into avg_sal from TbEmp where dno=deptno;end; call sp_avg_sal_by_dept(10, @a); select @a; 123456&gt;&gt;&gt; from django.db import connection&gt;&gt;&gt; cursor = connection.cursor()&gt;&gt;&gt; cursor.callproc('sp_avg_sal_by_dept', (10, 0))&gt;&gt;&gt; cursor.execute('select @_sp_avg_sal_by_dept_1')&gt;&gt;&gt; cursor.fetchone()(2675.0,) 使用数据分区。通过分区可以存储更多的数据、优化查询更大的吞吐量、可以快速删除过期的数据。关于这个知识点可以看看MySQL的官方文档。 RANGE分区：基于连续区间范围，把数据分配到不同的分区。 LIST分区：基于枚举值的范围，把数据分配到不同的分区。 HASH分区 / KEY分区：基于分区个数，把数据分配到不同的分区。 123456789CREATE TABLE tb_emp ( eno INT NOT NULL, ename VARCHAR(20) NOT NULL, job VARCHAR(10) NOT NULL, hiredate DATE NOT NULL, dno INT NOT NULL)PARTITION BY HASH(dno)PARTITIONS 4; 1234567891011121314CREATE TABLE tb_emp ( eno INT NOT NULL, ename VARCHAR(20) NOT NULL, job VARCHAR(10) NOT NULL, hiredate DATE NOT NULL, dno INT NOT NULL)PARTITION BY RANGE( YEAR(hiredate) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990), PARTITION p4 VALUES LESS THAN MAXVALUE); 使用explain来分析查询性能 - 执行计划。 1explain select * from ...; explain结果解析： select_type：表示select操作的类型，常见的值有SIMPLE（简单查询，没有使用子查询或者表连接查询）、PRIMARY（主查询，外层的查询）、UNION（并集操作中的第二个或者后面的查询）、SUBQUERY（子查询中的第一个SELECT）等。 table：输出结果的表。 type：MySQL在表中找到所需行的方式，也称为访问类型，常见的值有： ALL：全表扫描（遍历全表找到匹配的行） index：索引全扫描（遍历整个索引） range：索引范围扫描 ref：非唯一索引扫描或唯一索引的前缀扫描 eq_ref：唯一索引扫描 const / system：表中最多有一行匹配 NULL：不用访问表或者索引 possible_keys：查询时可能用到的索引。 key：实际使用的索引。 key_len：使用到索引字段的长度。 rows：扫描行的数量。 Extra：额外的信息（执行情况的说明或描述）。 说明：关于MySQL更多的知识尤其是性能调优和运维方面的内容，推荐大家阅读网易出品的《深入浅出MySQL（第2版）》，网易出品必属精品。 使用慢查询日志来发现性能低下的查询。 1234567891011121314mysql&gt; show variables like 'slow_query%';+---------------------------+----------------------------------+| Variable_name | Value |+---------------------------+----------------------------------+| slow_query_log | OFF || slow_query_log_file | /mysql/data/localhost-slow.log |+---------------------------+----------------------------------+ mysql&gt; show variables like 'long_query_time';+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+ 12mysql&gt; set global slow_query_log='ON'; mysql&gt; set global long_query_time=1; 1234[mysqld]slow_query_log=ONslow_query_log_file=/usr/local/mysql/data/slow.loglong_query_time=1","link":"/2018/04/29/Django知识点概述5/"},{"title":"Mac应用shell启动","text":"给App起别名1234vim ~/.zshrc#给App起别名alias vscode=\"/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code\"source ~/.zshrc 使用别名12vscode #启动VSCodevscode test.py #用VSCode打开文件","link":"/2017/02/06/Mac应用shell启动/"},{"title":"Mac FTP相关操作","text":"安装ftp命令123brew install telnet brew install inetutils brew link --overwrite inetutils ftp的使用登录 方式一 ftp server-ip 方式二 12345678910111213ftpftp&gt; open server-ip#ftp登录还有其他方式，这里只介绍两种。#以上命令之后，按提示输入用户名和密码。#当出现以下日志，表示连接成功#Connected to server-ip#220 (vsFTPd 2.2.2)#Name (10.0.5.11:lipengxiang): username#331 Please specify the password.#Password:#230 Login successful.#此时已经进入ftp命令行环境，此时如果进行本地目录或文件操作命令将发生一些变化，如下： 服务器操作 本地目录操作 cd 目录名（进入服务器目录） lcd 目录名（进入本机目录） cd \\（退到服务器根目录） lcd \\（退到本机根目录） cd ..（退回到上一级目录） lcd ..（退回到上一级目录） pwd !pwd ls !ls 上传文件server-filename 必须显式指明，否则报错：文件名无效 ftp&gt; put /local/path/filename /remote/path/server-filename 注意：向ftp服务器上传文件有两种模式 字符模式（ASCII）和二进制模式（Binary）。默认是ASCII模式。一般上传非文本文件要用二进制模式。登录ftp后，上传文件前，在ftp&gt;状态下输入bin即可(切换为二进制模式)。在ftp&gt;状态下输入asc(切换为ASCII模式) 批量上传使用通匹符批量上传文件至服务器，需要注意的一点，mput 不支持绝对路径，应该先进入要上传的本地文件夹及远程文件夹才可以操作。12345ftp&gt; cd /remote/pathftp&gt; lcd /local/pathftp&gt; mput file*local: file.jar remote: file.jar #注意：ftp不支持文件夹上传 文件下载下载服务器中的文件至本地目录中，可选指定下载至本地目录后的文件名称，依然要求提前进入待下载文件的目录中。123ftp&gt; get remote-filename local-filenamelocal-filename可省略，默认本地当前路径。#注意：关于下载文件夹， FTP 命令不支持文件夹下载操作。 删除文件ftp&gt; delete /remote/path/filename在服务器中删除文件，可以指定绝对路径，相对其他命令显得比较灵活。","link":"/2017/01/06/Mac-FTP相关操作/"},{"title":"Nginx学习一","text":"nginx的安装1234conf 配置文件html 网页文件logs log日志sbin 二进制文件 nginx其他命令1234ps aux|grep nginx 查看nginxcat nginx.pid 查看进程号killall -9 nginx 杀死进程kill -USR2 进程号 控制命令123456kill -USR2 cat nginx.pid #不是杀进程相当于重启nginx -t #检测配置是否成功nginx -s reload #重新加载配置文件nginx -s stop #立即停止nginx -s quit #优雅的停止 及当前访问的进程不加载🆕配置nginx -s reopen #重新加载日志配置 配置文件nginx.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#指定用什么用户去跑work process，默认用linux下的nobody用户 #user nobody; #工作进程数,可以设置为auto,nginx会探测cpu核心数，启动相同数量的work processworker_processes 1; #错误日志存放位置.既然叫错误日志，通常应设置级别为warn|error#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#主进程pid文件存放的地点#pid logs/nginx.pid;#events模块只能在main上下文中，并且只能配置一个，#其中可以包含7种简单指令events { worker_connections 1024; #每个worker process可以支持的最大连接数，生成环境根据需要可以设置更大一些（9000） #值得注意的是，此数字是包括了反向代理等等所需要的连接数在内，并不仅仅是指web端发起的连接数 #multi_accept on #是否work进程一次只接收一个连接。并发较大时应打开 #use epoll #选择底层处理连接的模型，Linux下默认epoll，无需自己设置 #accept_mutex #accept_mutex_delay #上面2参数是表示是否让worker进程使用one by one的工作模式，默认是关闭的。 #开启的时候，在低并发的时候非工作状态下的worker process将休眠，避免浪费资源。}#nginx配置的“核心”http { #include指令用于加载单独的配置文件模块，避免过于臃肿 #而这里的mime.types表示此文件应该在nginx.conf的同级目录下。 #其中的types模块用于表示nginx响应的文件后缀名和content-type直接的映射 #比如你想要让浏览器识别你返回的mytxt.data文件为文本内容在浏览器中显示为文本,添加 text/plain data; include mime.types; #上面的匹配失败后，默认给的响应内容类型 default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #io时不阻塞处理connection，在传输大文件时使用，细节待研究 sendfile on; #tcp_nopush on;#貌似意思是只有在sendfile启用时使用，让nginx发包的时候满包发送（不明白）通常不使用 #连接idle的最大时间，现代浏览器往往在一个页面同时打开多个connection传输js,css,html等。 #设置最大idle时间避免过长等待浪费connection #keepalive_timeout 0; keepalive_timeout 65; #开启response响应压缩，可以节省带宽，默认关闭。细节待研究 #gzip on; #server 上下文代表一个虚拟主机，可以有多个，内嵌在比如http,mail模块中 server { listen 80; server_name myapp.info; #如果是在本地试验，要修改/etc/hosts的域名映射到本机 location / { #location的匹配规则too tricky，单开一篇blog 注意匹配的文件夹的访问权限 root /usr/local/nginx; } } } 12worker_processes 一般为CPU数×核数关键还需看网卡的吞吐量 server配置虚拟主机123456Apache下配置&lt;virturlhost&gt; servername 域名 documentroot 路径&lt;/virturlhost&gt;说明该域名指向路径就行了 12345678nginx配置server { listen 80; server_name 域名; location / { root 文件路径; index index.php index.html; }","link":"/2017/01/23/Nginx学习一/"},{"title":"Git入门","text":"git - 简易指南Git是一个分散式版本控制软件。最初的目的是为了更好的管理Linux内核开发而设计。与CVS、 Subversion等集中式版本控制软件不同，Git不需要服务器端软件就可以发挥版本控制的作用。 使得代码的维护和发布变得非常方便。 Git库目录结构123456hooks : 存储钩子文件夹logs : 存储日志文件夹refs : 存储指向各个分支指针的(SHA-1)的文件夹objects : 存储git对象config : 存储配置文件HEAD : 指向当前分支的指针文件路径 安装下载 git OSX 版下载 git Windows 版下载 git Linux 版创建新仓库创建新文件夹，打开，然后执行git init以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子：git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令：12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：git push origin master 可以把 master 换成你想要推送的任何分支。如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：git remote add origin &lt;server&gt;如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去：git checkout -b feature_x 切换回主分支：git checkout master 再把新建的分支删掉：git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行：git pull以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行：git merge &lt;branch&gt;两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后， 你需要执行如下命令以将它们标记为合并成功：git add &lt;filename&gt; 在合并改动之前，也可以使用如下命令查看：git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：git tag 1.0.0 1b2e1d63ff1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：git log你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：git checkout -- &lt;filename&gt;此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：12git fetch origingit reset --hard origin/master 有用的贴士内建的图形化 git：gitk彩色的 git 输出：git config color.ui true显示历史记录时，只显示一行注释信息：git config format.pretty oneline交互地添加文件至缓存区：git add -i 为了使Git更好用，对Git做一些配置，.gitconfig文件中可以设置自定义命令等，.gitignore 文件是默认被忽略版本管理的文件。1234567891011121314151617181920212223242526272829303132333435[push] default = current[color] ui = auto[alias] aa = add --all ap = add --patch ca = commit --amend ci = commit -v co = checkout br = branch create-branch = !sh -c 'git push origin HEAD:refs/heads/$1 &amp;&amp; git fetch origin &amp;&amp; git branch --track $1 origin/$1 &amp;&amp; cd . &amp;&amp; git checkout $1' - delete-branch = !sh -c 'git push origin :refs/heads/$1 &amp;&amp; git branch -D $1' - merge-branch = !git checkout master &amp;&amp; git merge @{-1} pr = !hub pull-request st = status up = !git fetch origin &amp;&amp; git rebase origin/master[core] excludesfile = ~/.gitignore autocrlf = input[merge] ff = only[include] path = .gitconfig.local[commit] template = ~/.gitmessage[fetch] prune = true[user] name = zgs225 email = zgs225@gmail.com[credential] helper = osxkeychain[github] user = zgs225 原文","link":"/2017/01/27/Git入门/"},{"title":"Nginx学习二","text":"日志管理 12345678910111213141516171819202122232425262728293031http{ log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 5000; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { #自定义日志 路径、格式 access_log logs/php.log main; root /workspace/WebServer/php; index index.html index.htm index.php; } }} PathInfo12345678 location ~ \\.php(.*)$ {#使用正则抓取路径 root /Users/dingyd/workspace/WebServer/php; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $1;#给后端服务器传递参数 include fastcgi_params;} Url重写(正则表达式) 支持简单的if判断 例如-e表示文件是否存在1234567 location / { #自定义日志 路径、格式 access_log logs/php.log main; root /workspace/WebServer/php; index index.html index.htm index.php; rewrite (&lt;*)$/index.php/$1; #将www.baidu.com/user/login -&gt; www.baidu.com/index,php/user/login } try_files1234567 location / { #自定义日志 路径、格式 access_log logs/php.log main; root /workspace/WebServer/php; index index.html index.htm index.php; try_files $uri /index.php/$url; #尝试www.baidu.com/user/login是否存在文件夹 如果不存在则指向www.baidu.com/index,php/user/login } 反向代理12345## 动静分离 location ~ \\.(jpg|png|jpeg|gif) { proxy_set_header X-Forwarded_For $remote_addr;#代理地址 proxy_pass https://ip:port;} 集群与负载均衡","link":"/2017/01/29/Nginx学习二/"},{"title":"OC对象的底层实现原理探索","text":"","link":"/2019/05/16/OC对象的底层实现原理探索/"},{"title":"Mac开发配置","text":"Homebrew安装123# OSX系统基本上都自带Ruby1.9# 所以无需先安装Ruby，但是之后我们需要管理Rubyruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" brew常用命令12345678910brew list # 查看已经安装的包brew update # 更新Homebrew自身brew doctor # 诊断关于Homebrew的问题(Homebrew 有问题时请用它)brew cleanup # 清理老版本软件包或者无用的文件brew show ${formula} # 查看包信息brew search ${formula} # 按名称搜索brew upgrade ${formula} # 升级软件包brew install ${formula} # 按名称安装brew uninstall ${formula} # 按名称卸载brew pin/unpin ${formula} # 锁定或者解锁软件包版本，防止误升级 ZSH查看系统支持的shell1cat /etc/shells 切换默认shell12345678910111213# 切换zsh为默认shellchsh -s $(which zsh)#如果你想使用最新的zsh，你可以使用Homebrew，此方法也会保留原生的zsh，防止你在某个 时刻需要它。#查看最新zsh信息brew info zsh# 安装zshbrew install --disable-etcdir zsh# 添加shell路径至/etc/shells文件中# 将 /usr/local/bin/zsh 添加到下面文件中sudo vim /etc/shells# 更换默认shellchsh -s /usr/local/bin/zsh 待续","link":"/2017/01/26/Mac开发配置/"},{"title":"Python 虚拟机","text":"virtualenvwrapper1virtualenvwrapper 是一个基于 virtualenv 之上的工具，它将所有的虚拟环境集中起来管理。 安装sudo pip install virtualenvwrapper 配置1234vim ~/.bashrcexport WORKON_HOME=~/workspaces #存放虚拟环境的位置source /usr/bin/virtualenvwrapper.sh 使用123456mkvirtualenv env1 #创建workon env1 #切换虚拟机cpvirtualenv env1 env3 #赋值虚拟机rmvirtualenv env2 #删除虚拟机pip list #查看虚拟机中的packagesdeactivate #退出 其他命令1234lsvirtualenv #显示所有虚拟环境。cdvirtualenv #跳转至当前虚拟环境目录，方便查看虚拟环境的 site-packages 目录。cdsitepackages #直接跳转至当前虚拟环境的 site-packages 目录。lssitepackages #显示当前虚拟环境的 site-packages 目录内容。","link":"/2017/04/30/Python-虚拟机/"},{"title":"Django知识点概述6","text":"项目调试可以使用django-debug-toolbar来辅助项目调试。 安装 1pip install django-debug-toolbar 配置 - 修改settings.py。 12345678910111213141516INSTALLED_APPS = [ 'debug_toolbar',] MIDDLEWARE = [ 'debug_toolbar.middleware.DebugToolbarMiddleware',] DEBUG_TOOLBAR_CONFIG = { # 引入jQuery库 'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js', # 工具栏是否折叠 'SHOW_COLLAPSED': True, # 是否显示工具栏 'SHOW_TOOLBAR_CALLBACK': lambda x: True,} 配置 - 修改urls.py。 12345if settings.DEBUG: import debug_toolbar urlpatterns.insert(0, path('__debug__/', include(debug_toolbar.urls))) 使用 - 在页面右侧可以看到一个调试工具栏，上面包括了执行时间、项目设置、请求头、SQL、静态资源、模板、缓存、信号等调试信息，查看起来非常的方便。 性能相关网站优化两大定律： 尽可能的使用缓存 - 牺牲空间换取时间（普适策略）。 能推迟的都推迟 - 使用消息队列将并行任务串行来缓解服务器压力。 服务器CPU利用率出现瞬时峰值 - 削峰（CPU利用率平缓的增长） 上下游节点解耦合（下订单和受理订单的系统通常是分离的） Django框架 配置缓存来缓解数据库的压力，并有合理的机制应对缓存穿透和缓存雪崩。 开启模板缓存来加速模板的渲染。 123456789101112131415161718192021TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates'), ], # 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], 'loaders': [( 'django.template.loaders.cached.Loader', [ 'django.template.loaders.filesystem.Loader', 'django.template.loaders.app_directories.Loader', ], ), ], }, },] 用惰性求值、迭代器、defer()、only()等缓解内存压力。 用select_related()和prefetch_related()执行预加载避免“1+N查询问题”。 用户敏感信息的保护 哈希摘要（签名） 123456789101112&gt;&gt;&gt; import hashlib&gt;&gt;&gt; &gt;&gt;&gt; md5_hasher = hashlib.md5()&gt;&gt;&gt; md5_hasher.update('hello, world!'.encode())&gt;&gt;&gt; md5_hasher.hexdigest()'3adbbad1791fbae3ec908894c4963870'&gt;&gt;&gt;&gt;&gt;&gt; sha1_hasher = hashlib.sha1()&gt;&gt;&gt; sha1_hasher.update('hello, world!'.encode())&gt;&gt;&gt; sha1_hasher.update('goodbye, world!'.encode())&gt;&gt;&gt; sha1_hasher.hexdigest()'1f09d30c707d53f3d16c530dd73d70a6ce7596a9' 加密和解密（对称加密和非对称加密） 1pip install rsa 12345678&gt;&gt;&gt; pub_key, pri_key = rsa.newkeys(1024)&gt;&gt;&gt; message = 'hello, world!'&gt;&gt;&gt; crypto = rsa.encrypt(message.encode(), pub_key)&gt;&gt;&gt; cryptob'Ou{gH\\xa9\\xa8}O\\xe3\\x1d\\x052|M\\x9d9?\\xdc\\xd8\\xecF\\xd3v\\x9b\\xde\\x8e\\x12\\xe6M\\xebvx\\x08\\x08\\x8b\\xe8\\x86~\\xe4^)w\\xf2\\xef\\x9e\\x9fOg\\x15Q\\xb7\\x7f\\x1d\\xcfV\\xf1\\r\\xbe^+\\x8a\\xbf }\\x10\\x01\\xa4U9b\\x97\\xf5\\xe0\\x90T\\'\\xd4(\\x9b\\x00\\xa5\\x92\\x17\\xad4\\xb0\\xb0\"\\xd4\\x16\\x94*s\\xe1r\\xb7L\\xe2\\x98\\xb7\\x7f\\x03\\xd9\\xf2\\t\\xee*\\xe6\\x93\\xe6\\xe1o\\xfd\\x18\\x83L\\x0cfL\\xff\\xe4\\xdd%\\xf2\\xc0/\\xfb'&gt;&gt;&gt; origin = rsa.decrypt(crypto, pri_key).decode()&gt;&gt;&gt; origin'hello, world!' 1pip install pycrypto AES对称加密： 123456789101112&gt;&gt;&gt; from hashlib import md5&gt;&gt;&gt;&gt;&gt;&gt; from Crypto.Cipher import AES&gt;&gt;&gt; from Crypto import Random&gt;&gt;&gt;&gt;&gt;&gt; key = md5(b'mysecret').hexdigest()&gt;&gt;&gt; iv = Random.new().read(AES.block_size)&gt;&gt;&gt; str1 = '我爱你们！'&gt;&gt;&gt; str2 = AES.new(key, AES.MODE_CFB, iv).encrypt(str1)b'p\\x96o\\x85\\x0bq\\xc4-Y\\xc4\\xbcp\\n)&amp;'&gt;&gt;&gt; str3 = AES.new(key, AES.MODE_CFB, iv).decrypt(str2).decode()'我爱你们！' RSA非对称加密： 123456789101112131415&gt;&gt;&gt; from Crypto.PublicKey import RSA&gt;&gt;&gt; # 生成密钥对&gt;&gt;&gt; key_pair = RSA.generate(2048)&gt;&gt;&gt; # 导入公钥&gt;&gt;&gt; pub_key = RSA.importKey(key_pair.publickey().exportKey())&gt;&gt;&gt; # 导入私钥&gt;&gt;&gt; pri_key = RSA.importKey(key_pair.exportKey())&gt;&gt;&gt; # 明文&gt;&gt;&gt; message1 = 'hello, world!'.encode()&gt;&gt;&gt; # 加密数据&gt;&gt;&gt; message2 = pub_key.encrypt(message1, None)(b'\\x03\\x86t\\xa0\\x00\\xc4\\xea\\xd2\\x80\\xed\\xa7YN7\\x07\\xff\\x88\\xaa\\x1eW\\x0cmH0\\x06\\xa7\\'\\xbc&lt;w@q\\x8b\\xaf\\xf7:g\\x92{=\\xe2E\\xa5@\\x1as2\\xdd\\xcb\\x8e[\\x98\\x85\\xdf,X\\xecj.U\\xd6\\xa7W&amp;u\\'Uz\"\\x0f\\x0e\\\\&lt;\\xa4\\xfavC\\x93\\xa7\\xbcO\"\\xb9a\\x06]&lt;.\\xc1\\r1}*\\xdf\\xccdqXML\\x93\\x1b\\xe9\\xda\\xdf\\xab|\\xf8\\x18\\xe4\\x99\\xbb\\x7f\\x18}\\xd9\\x9a\\x1e*J\\\\\\xca\\x1a\\xd1\\x85\\xf7t\\x81\\xd95{\\x19\\xc9\\x81\\xb6^}\\x9c5\\xca\\xfe\\xcf\\xc8\\xd8M\\x9a\\x8c-\\xf1t\\xee\\xf9\\x12\\x90\\x01\\xca\\x92~\\x00c5qg5g\\x95&amp;\\x10\\xb1\\x0b\\x1fo\\x95\\xf2\\xbc\\x8d\\xf3f\"@\\xc5\\x188\\x0bX\\x9cfo\\xea\\x97\\x05@\\xe5\\xb2\\xda\\xb8\\x97a\\xa5w\\xa8\\x01\\x9a\\xa5N\\xc4\\x81\\x8d\\x0f&lt;\\x96iU\\xd3\\x95\\xacJZs\\xab_ #\\xee\\xf9\\x0f\\xf2\\x12\\xdb\\xfc\\xf8g\\x18v\\x02k+\\xda\\x16Si\\xbf\\xbb\\xec\\xf7w\\x90\\xde\\xae\\x97\\t\\xed{}5\\xd0',)&gt;&gt;&gt; # 解密数据&gt;&gt;&gt; message3 = pri_key.decrypt(message2)'hello, world!' 安全相关建议 虽然 Django 自带了稳固的安全保护措施，但是依然要采用正确的方式部署应用程序，利用 Web 服务器、操作系统和其他组件提供的安全保护措施。 记得把 Python 代码放在 Web 服务器的文档根目录之外，避免代码意外泄露。 谨慎处理用户上传的文件。 Django本身没有对请求次数加以限制（包括验证用户身份的请求），为了防止暴力攻击和破解，可以考虑使用具有一次消费性的验证码或对这类请求的次数进行限制。 将缓存系统、数据库服务器以及重要的资源服务器都放在第二级防火墙之后（不要放在DMZ）。","link":"/2018/05/02/Django知识点概述6/"},{"title":"Python-单例模式","text":"12345\"\"\"装饰类的装饰器 - 单例模式 - 一个类只能创建出唯一的对象上下文语法：__enter__ / __exit__\"\"\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingfrom functools import wrapsdef singleton(cls): \"\"\"单例装饰器\"\"\" instances = {} lock = threading.Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with lock: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass President(): def __init__(self, name, country): self.name = name self.country = country def __str__(self): return f'{self.country}: {self.name}'def main(): print(President.__name__) p1 = President('特朗普', '美国') p2 = President('奥巴马', '美国') print(p1 == p2) print(p1) print(p2)if __name__ == '__main__': main()","link":"/2017/06/09/Python-单例模式/"},{"title":"Python-装饰器","text":"12345\"\"\"装饰器 - 装饰器中放置的通常都是横切关注（cross-concern）功能所谓横切关注功能就是很多地方都会用到但跟正常业务又逻辑没有必然联系的功能装饰器实际上是实现了设计模式中的代理模式 - AOP（面向切面编程）\"\"\" 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from functools import wrapsfrom random import randintfrom time import time, sleepimport pymysqldef record(output): def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() ret_value = func(*args, **kwargs) output(func.__name__, time() - start) return ret_value return wrapper return decoratedef output_to_console(fname, duration): print('%s: %.3f秒' % (fname, duration))def output_to_file(fname, duration): with open('log.txt', 'a') as file_stream: file_stream.write('%s: %.3f秒\\n' % (fname, duration))def output_to_db(fname, duration): con = pymysql.connect(host='localhost', port=3306, database='test', charset='utf8', user='root', password='123456', autocommit=True) try: with con.cursor() as cursor: cursor.execute('insert into tb_record values (default, %s, %s)', (fname, '%.3f' % duration)) finally: con.close()@record(output_to_console)def random_delay(min, max): sleep(randint(min, max))def main(): for _ in range(3): # print(random_delay.__name__) random_delay(3, 5) # for _ in range(3): # # 取消掉装饰器 # random_delay.__wrapped__(3, 5)if __name__ == '__main__': main()","link":"/2017/06/09/Python-装饰器/"},{"title":"Python-迭代器","text":"1234\"\"\"迭代器 - __iter__ / __next__itertools - 生成可迭代序列的工具模块\"\"\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import itertoolsfrom math import sqrtdef is_prime(num): \"\"\"判断素数\"\"\" for factor in range(2, int(sqrt(num)) + 1): if num % factor == 0: return False return Trueclass PrimeIter(object): \"\"\"素数迭代器\"\"\" def __init__(self, min_value, max_value): assert 2 &lt;= min_value &lt;= max_value self.min_value = min_value - 1 self.max_value = max_value def __iter__(self): return self def __next__(self): self.min_value += 1 while self.min_value &lt;= self.max_value: if is_prime(self.min_value): return self.min_value self.min_value += 1 raise StopIteration()class FibIter(object): \"\"\"斐波那契数迭代器\"\"\" def __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx &lt; self.num: self.a, self.b = self.b, self.a + self.b self.idx += 1 return self.a raise StopIteration()def main(): # for val in itertools.permutations('ABCD'): # print(val) # for val in itertools.combinations('ABCDE', 3): # print(val) # for val in itertools.product('黑红梅方', range(1, 14)): # print(val) # fib_iter = FibIter(20) # print('===&gt;', next(fib_iter)) # print('===&gt;', next(fib_iter)) # for val in fib_iter: # print(val) prime_iter = PrimeIter(2, 100000) for val in prime_iter: print(val)if __name__ == '__main__': main()","link":"/2017/06/11/Python-迭代器/"},{"title":"NoSQL-Redis","text":"NoSQL数据库按照其存储类型可以大致分为以下几类： 类型 部分代表 特点 列族数据库 HBaseCassandraHypertable 顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的I/O优势，适合于批量数据处理和即时查询。 文档数据库 MongoDBCouchDBElasticSearch 文档数据库一般用类JSON格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。 KV数据库 DynamoDBRedisLevelDB 可以通过key快速查询到其value，有基于内存和基于磁盘两种实现方案。 图数据库 Neo4JFlockDBJanusGraph 使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。 对象数据库 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 Redis概述Redis是一种基于键值对的NoSQL数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis还支持键过期、地理信息运算、发布订阅、事务、管道、Lua脚本扩展等功能，总而言之，Redis的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给Redis就可以了。目前，国内外很多著名的企业和商业项目都使用了Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。 Redis简介Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： Redis的读写性能极高，并且有丰富的特性（发布/订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog等。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。 Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。 Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。 Redis的应用场景 高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀/投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。 Redis的安装和配置可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 12345wget http://download.redis.io/releases/redis-5.0.4.tar.gzgunzip redis-5.0.4.tar.gztar -xvf redis-5.0.4.tarcd redis-5.0.4make &amp;&amp; make install Redis的服务器和客户端接下来启动Redis服务器，下面的方式将以默认的配置启动Redis服务。 1redis-server 如果希望修改Redis的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。 方式一：通过参数指定认证口令和AOF持久化方式。 1redis-server --requirepass 1qaz2wsx --appendonly yes 方式二：通过指定的配置文件来修改Redis的配置。 1redis-server /root/redis-5.0.4/redis.conf 下面我们使用第一种方式来启动Redis并将其置于后台运行，将Redis产生的输出重定向到名为redis.log的文件中。 1redis-server --requirepass 1qaz2wsx &gt; redis.log &amp; 可以通过ps或者netstat来检查Redis服务器是否启动成功。 12ps -ef | grep redis-servernetstat -nap | grep redis-server 接下来，我们尝试用Redis客户端去连接服务器。 123456redis-cli127.0.0.1:6379&gt; auth 1qaz2wsxOK127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; Python中的使用1234567891011121314151617181920212223import base64import jsonimport redisfrom example02 import Personclass PersonJsonEncoder(json.JSONEncoder): def default(self, o): return o.__dict__def main(): cli = redis.StrictRedis(host='120.77.222.217', port=6379, password='123123') data = base64.b64decode(cli.get('guido'))if __name__ == '__main__': main()","link":"/2018/09/19/NoSQL-Redis/"},{"title":"Swift面向协议 POP","text":"基于 Swift 的面向协议编程12面向对象的设计和面向协议的设计都使用了多态让我们使用同样的接口来跟不同的类型进行交互。在面向对象的设计中，我们使用了基类提供的接口来跟所有的子类进行交互。在面向协议的设计中，我们使用了协议和协议扩展提供的接口来跟遵守该协议的类型进行交互。两种设计方式写出的代码都很好而且易懂。但个人感觉协议/协议扩展代码更好，因为协议/协议扩展的方法整体更干净和易懂些。' 12在面向协议设计中我们更多的使用了值类型（结构体struct）而非引用类型（类class）。Apple已经说了我们应该在合适的地方尽可能地偏好使用值类型而非引用类型。 未完待续","link":"/2019/05/04/Swift面向协议-POP/"},{"title":"VSCode插件化","text":"开发vscode代码提示插件打开seting.json123\"[markdown]\": { \"editor.quickSuggestions\": true } userCode添加12345678910111213141516171819{ \"categories\": { \"prefix\": \"cate\", \"body\": [ \"toc: true\", \"categories: [$0]\" ], \"description\": \"categories\" }, \"python-code\": { \"prefix\": \"python-code\", \"body\": [ \"```python\", \"$0\", \"```\", ], \"description\": \"这是python的多行代码块\" }} 效果如下 VSCode官方文档","link":"/2019/05/08/VSCode插件化/"},{"title":"Python-零碎点","text":"123456\"\"\"变量的作用域以及Python搜索变量的顺序LEGB: Local --&gt; Embedded --&gt; Global --&gt; Built-inglobal - 声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）nonlocal - 声明使用嵌套作用域的变量（如果嵌套作用域没有对应的变量直接报错）\"\"\" 1234567\"\"\"多重继承 - 一个类有两个或者两个以上的父类MRO - 方法解析顺序 - Method Resolution Order当出现菱形继承（钻石继承）的时候，子类到底继承哪个父类的方法Python 2.x - 深度优先搜索Python 3.x - C3算法 - 类似于广度优先搜索\"\"\"","link":"/2017/06/10/Python-零碎点/"},{"title":"Python-枚举","text":"12345\"\"\"面向对象枚举 - 一个变量的值只有有限个选择，最适合的类型就是枚举通过枚举我们可以定义符号常量，符号常量优于字面常量\"\"\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from enum import Enum, uniqueimport random@uniqueclass Suite(Enum): \"\"\"花色（枚举）\"\"\" SPADE = 0 HEART = 1 CLUB = 2 DIAMOND = 3 def __lt__(self, other): return self.value &lt; other.valueclass Card(): \"\"\"牌\"\"\" def __init__(self, suite, face): self.suite = suite self.face = face def __repr__(self): return self.__str__() def __str__(self): suites = ('♠️', '♥️', '♣️', '♦️') faces = ('', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K') return f'{suites[self.suite.value]} {faces[self.face]}'class Poker(): \"\"\"扑克\"\"\" def __init__(self): self.index = 0 self.cards = [Card(suite, face) for suite in Suite for face in range(1, 14)] def shuffle(self): \"\"\"洗牌\"\"\" self.index = 0 random.shuffle(self.cards) def deal(self): \"\"\"发牌\"\"\" card = self.cards[self.index] self.index += 1 return card @property def has_more(self): \"\"\"是否有更多的牌\"\"\" return self.index &lt; len(self.cards)class Player(): \"\"\"玩家\"\"\" def __init__(self, name): self.name = name self.cards = [] def get_card(self, card): \"\"\"摸牌\"\"\" self.cards.append(card) def arrange(self): \"\"\"整理手上的牌\"\"\" self.cards.sort(key=lambda card: (card.suite, card.face))def main(): \"\"\"主函数\"\"\" poker = Poker() poker.shuffle() players = [ Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐') ] while poker.has_more: for player in players: player.get_card(poker.deal()) for player in players: player.arrange() print(player.name, end=': ') print(player.cards)if __name__ == '__main__': main()","link":"/2017/06/11/Python-枚举/"},{"title":"iOS 开发相关开源库","text":"开发相关开源库 1、腾讯开源，提高项目 UI 开发效率的解决方案：QMUI_iOS 2、iOS 组件化、解藕最佳方案，最强大的动态路由库：FFRouter 3、iOS逆向开发工具：MonkeyDev 4、自动创建带有调试信息的appIcon的脚本：LLIconVersioning 5、iOS 性能分析和测试框架：DetoxInstruments 6、WebView OC与JS通信框架：WebViewJavascriptBridge 7、一个简单的UITableView/UICollectionView的superclass category，用于无数据时自动显示空视图：DZNEmptyDataSet 8、iOS代码自动翻新(混淆)工具：WHC_ConfuseSoftware 9、一个可以观看国内主流视频平台所有vip视频的Mac客户端：ivideo 10、开屏广告、启动广告解决方案-支持静态/动态图片广告,mp4视频广告,全屏/半屏广告：XHLaunchAd 11、一款功能强大的 macOS 版微信小助手，支持防撤回、多开、自动回复：WeChatPlugin-MacOS 12、iOS APP内调试工具，支持抓包、Crash收集、沙盒文件浏览等：LLDebugTool 13、一款iOS苹果远程推送测试程序,Mac OS 下的 APNS 工具：SmartPush 14、Mac里provisionprofile和mobileprovision文件管理器工具：ProfilesManager 15、iOS跑马灯大全：MarqueeLabel 16、支持iOS/tvOS/OSX的漂亮图表、统计图：Charts 17、一行代码设置状态栏、导航栏按钮、标题、颜色、透明度，移动等：WRNavigationBar 18、用于原生渲染After Effects矢量动画的iOS库：lottie-ios 19、Core Data和SQLite的替代品：realm-cocoa 20、Mac OS开源密码存储工具：MacPass","link":"/2016/12/13/iOS-开发相关开源库/"},{"title":"iOSUIWebView点击放大图片","text":"1234567891011121314151617181920212223242526272829303132333435363738- (void)webViewDidFinishLoad:(UIWebView *)webView{ // 更改html所有字体大小 NSString *str = @\"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '90%'\"; [_webView stringByEvaluatingJavaScriptFromString:str]; // 计算内容高度 CGRect frame = webView.frame; frame.size.width = SCREEN_WIDTH; frame.size.height = 1; webView.frame = frame; frame.size.height = webView.scrollView.contentSize.height; NSLog(@\"webViewDidFinishLoadframe = %@\", [NSValue valueWithCGRect:frame]); //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @\"function getImages(){\\ var objs = document.getElementsByTagName(\\\"img\\\");\\ var imgScr = '';\\ for(var i=0;i&lt;objs.length;i++){\\ imgScr = imgScr + objs[i].src + '+';\\ \\ objs[i].onclick=function(){\\ document.location=\\\"myweb:imageClick:\\\"+this.src;\\ };\\ };\\ return imgScr;\\ };\";//这里获取网页中img标签对象 [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResurlt = [webView stringByEvaluatingJavaScriptFromString:@\"getImages()\"]; _mUrlArray = @[].mutableCopy; // 判断数组中是否已经存在 for (NSString *str in [NSMutableArray arrayWithArray:[urlResurlt componentsSeparatedByString:@\"+\"]]) { [_mUrlArray addObject:str]; } [_mUrlArray removeObject:_mUrlArray.lastObject]; } 12345678910111213141516171819- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{ //将url转换为string NSString *requestString = [[request URL] absoluteString]; //hasPrefix 判断创建的字符串内容是否以pic:字符开始 if ([requestString hasPrefix:@\"myweb:imageClick:\"]) { NSString * imageUrl = [requestString substringFromIndex:@\"myweb:imageClick:\".length]; //获取当前图片的url在整个链接地址中位置 NSInteger index = [_mUrlArray indexOfObject:imageUrl]; /** *此处展示图片 */ return NO; } else if ([requestString hasPrefix:@\"http\"]){ //跳转链接 } return YES;}","link":"/2016/12/13/iOSUIWebView点击放大图片/"},{"title":"iOS实现markdown预览","text":"iOS实现markdown预览效果图","link":"/2019/03/23/iOS实现markdown预览/"},{"title":"Swift  Result<T, E: Error> 枚举类型","text":"Swift 枚举类型Swift 中枚举的能力相比 OC 有着很大的进步，每个枚举值除了可以是常规的基础类型，还可以是一个关联的类型。有了这样的特性后用枚举来优化返回结果的数据结构显得水到渠成： 12345678enum Result&lt;Success, Failure&gt; where Failure : Error { /// A success, storing a `Success` value. case success(Success) /// A failure, storing a `Failure` value. case failure(Failure)} 基本用法定义异步返回结果是 Int 类型的函数：123456789101112func fetchData(_ completionHandler: @escaping (Result&lt;Int, Error&gt;) -&gt; Void) { DispatchQueue.global().async { let isSuccess = true if isSuccess { let resultValue = 6 return completionHandler(.success(resultValue)) } else { let error = NSError(domain: \"custom error\", code: -1, userInfo: nil) return completionHandler(.failure(error)) } }} 返回值的类型通过泛型进行约束， Result 第一个泛型类型表示返回值的类型，第二个类型表示错误的类型。对 Result 赋值和常规的枚举一样：1let valueResult: Result&lt;Int, CustomError&gt; = Result.success(4) // 因为 swift 中会进行类型推断，编译器在确认返回的是 Result 类型后，可以省略枚举类型的声明let errorResult = .failure(CustomError.inputNotValid)取出 Result 值和获取普通的关联类型枚举是一样的：12345678fetchData { (result) in switch result { case .success(let value): print(value) case .failure(let error) print(error.localizedDescription) }} 如果你只想要获取其中一项的值，也可以直接用 if case 拆包：12345fetchDate { (result) in if case .success(let value) = result { print(value) }} 可以判等Enum 是一个值类型，是一个值就应该可以判断是否相等。如果 Result 的成功和失败的类型都是 Equatable，那么 Result 就可以判等，源码如下：1extension Result : Equatable where Success : Equatable, Failure : Equatable { } 类似的，如果是成功和失败的类型都是 Hashable，那么 Result 也是 Hashable：1extension Result : Hashable where Success : Hashable, Failure : Hashable { } 如果实现了 Hashable ，可以用来当做字典的 key。 辅助的 APImap、mapError与 Dictionary 类似，Swift 为 Result 提供了几个 map value 和 error 的方法。1234567891011let intResult: Result&lt;Int, Error&gt; = Result.success(4)let stringResult = x.map { (value) -&gt; Result&lt;String, Error&gt; in return .success(\"map\")}let originError = NSError(domain: \"origin error\", code: -1, userInfo: nil)let errorResult: Result&lt;Int, Error&gt; = .failure(originError)let newErrorResult = errorResult.mapError { (error) -&gt; Error in let newError = NSError(domain: \"new error\", code: -2, userInfo: nil) return newError} flatMap、flatMapErrormap 返回的是具体的结果和错误， flatMap 闭包中返回的是 Result 类型。如果 Result 中包含的是数据，效果和 map 一致，替换数据；如果 Result 中包含的是错误，那么不替换结果。1234567891011let intResult: Result&lt;Int, Error&gt; = Result.success(4)// 替换成功let flatMapResult = intResult.flatMap { (value) -&gt; Result&lt;String, Error&gt; in return .success(\"flatMap\")}// 没有执行替换操作，flatMapIntResult 值还是 intResultlet flatMapIntResult = intResult.flatMap { (value) -&gt; Result&lt;String, Error&gt; in return .failure(NSError(domain: \"origin error\", code: -1, userInfo: nil))} get很多时候只关心 Result 的值， Swift 提供了 get() 函数来便捷的直接获取值，需要注意的是这个函数被标记为 throws，使用时语句前需要加上 try：123let intResult: Result&lt;Int, Error&gt; = Result.success(4)let value = try? intResult.get() 可抛出异常的闭包初始化器很多时候获取返回值的闭包中可能会发生异常代表获取失败的错误，基于这个场景 Swift 提供了一个可抛出异常的闭包初始化器：12345678910111213enum CustomError: Error, Equatable { case inputNotValid}let fetchInt = { () -&gt; Int in if true { return 4 } else { throw CustomError.inputNotValid }}let result: Result&lt;Int, Error&gt; = Result { try fetchInt() } 需要提醒是通过这种方式声明的 Result 的 error 类型只能是 Error，不能指定特定的 Error。","link":"/2019/05/03/Swift-Result-T-E-Error-枚举类型/"},{"title":"iOS脚本自动打包发布及自动检测更新","text":"使用到的第三方平台 蒲公英 集成蒲公英SDK 1234pod 'PgyUpdate'//启动更新检查SDK[[PgyUpdateManager sharedPgyManager] startManagerWithAppId:@\"appkey\"];//在蒲公英平台获取[[PgyUpdateManager sharedPgyManager] checkUpdate]; 由于蒲公英平台更新APP的条件是根据Version和build的值判断更新，所以每次打包时build加1 iOS手动打包添加脚本打包build自增 选择build phases， 在其中添加run Script 脚本，其内容如下： 123456if [ \"$CONFIGURATION\" != \"Debug\" ]thenbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"fi 自动打包脚本 在脚本的编译开始时添加如下代码 12345# 工程的Bundle +1buildNumber=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/${project_name}/Info.plist)echo $buildNumberbuildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c /usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/@{project_name}/Info.plist 上传到测试平台 123456#上传到Fir# 将XXX替换成自己的Fir平台的token#fir login -T XXX#fir publish $exportIpaPath/$scheme_name.ipaipaPath=${exportIpaPath}/${scheme_name}.ipacurl -F file=@${ipaPath} -F '_api_key=XXX' https://www.pgyer.com/apiv2/app/upload 自动化打包脚本 选择打包平台app-store 或者ad-hoc 选择App Store时打包完成上传到App Store 选择adhoc时上传到对应的平台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#使用方法if [ ! -d ./IPADir ];thenmkdir -p IPADir;fi#工程绝对路径project_path=$(cd `dirname $0`; pwd)#工程名 将XXX替换成自己的工程名project_name=XXX#scheme名 将XXX替换成自己的sheme名scheme_name=XXX#打包模式 Debug/Releasedevelopment_mode=Debug#build文件夹路径build_path=${project_path}/build#plist文件所在路径exportOptionsPlistPath=${project_path}/exportTest.plist#导出.ipa文件所在路径exportIpaPath=${project_path}/IPADir/${development_mode}echo \"请输入要导出的的平台 ? [ 1:app-store 2:ad-hoc] \"##read numberwhile([[ $number != 1 ]] &amp;&amp; [[ $number != 2 ]])doecho \"报错! 只能选择平台 1 或 2\"echo \"请重新输入要导出的的平台 ? [ 1:app-store 2:ad-hoc] \"read numberdoneif [ $number == 1 ];thendevelopment_mode=ReleaseexportOptionsPlistPath=${project_path}/exportAppstore.plistelsedevelopment_mode=ReleaseexportOptionsPlistPath=${project_path}/exportTest.plistfi#note: Using new build systemerror: Could not delete `XXX` because it was not created by the build system.rm -rf ${build_path}echo '///-----------'echo '/// 正在清理工程'echo '///-----------'xcodebuild \\clean -configuration ${development_mode} -quiet || exitecho '///--------'echo '/// 清理完成'echo '///--------'echo ''echo '///-----------'echo '/// 正在编译工程:'${development_mode}echo '///-----------'# 工程的Bundle +1buildNumber=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/${project_name}/Info.plist)echo $buildNumberbuildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c /usr/libexec/PlistBuddy -c \"print CFBundleVersion\" ${project_path}/@{project_name}/Info.plist#编译工程/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuildxcodebuild \\archive -workspace ${project_path}/${project_name}.xcworkspace \\-scheme ${scheme_name} \\-configuration ${development_mode} \\-archivePath ${build_path}/${project_name}.xcarchive -quiet || exitecho '///--------'echo '/// 编译完成'echo '///--------'echo ''echo '///----------'echo '/// 开始ipa打包'echo '///----------'xcodebuild -exportArchive -archivePath ${build_path}/${project_name}.xcarchive \\-configuration ${development_mode} \\-exportPath ${exportIpaPath} \\-exportOptionsPlist ${exportOptionsPlistPath} \\-quiet || exitif [ -e $exportIpaPath/$scheme_name.ipa ]; thenecho '///----------'echo '/// ipa包已导出'echo '///----------'open $exportIpaPathelseecho '///-------------'echo '/// ipa包导出失败 'echo '///-------------'fiecho '///------------'echo '/// 打包ipa完成 'echo '///-----------='echo ''echo '///-------------'echo '/// 开始发布ipa包 'echo '///-------------'if [ $number == 1 ];then#验证并上传到App Store# 将-u 后面的XXX替换成自己的AppleID的账号，-p后面的XXX替换成自己的密码altoolPath=\"/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool\"\"$altoolPath\" --validate-app -f ${exportIpaPath}/${scheme_name}.ipa -u XXX -p XXX -t ios --output-format xml\"$altoolPath\" --upload-app -f ${exportIpaPath}/${scheme_name}.ipa -u XXX -p XXX -t ios --output-format xmlelse#上传到Fir# 将XXX替换成自己的Fir平台的token#fir login -T XXX#fir publish $exportIpaPath/$scheme_name.ipaipaPath=${exportIpaPath}/${scheme_name}.ipacurl -F file=@${ipaPath} -F '_api_key=XXX' https://www.pgyer.com/apiv2/app/uploadfiexit 0 exportTest.plist 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;ad-hoc&lt;/string&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt;&lt;/dict&gt;&lt;/plist&gt; exportAppstore.plist 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;uploadBitcode&lt;/key&gt; &lt;true/&gt; &lt;key&gt;uploadSymbols&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt;","link":"/2017/05/18/iOS脚本自动打包发布及自动检测更新/"},{"title":"iOS之hash与isEqual","text":"iOS之hash与isEqual外什么要重写hash与isEqual 重写hash的原因 1234567oc与swift 的集合与字典是基于哈希表的、即hashSet与hashMap由于哈希表实现的哈希函数的特性：将一个整形经过取模转换成比较小的整数，作为数组的索引 1 所以我们将自定义对象作为key传给集合或者字典时，这个key必须是可哈希的 2 即：hashMap的hashWithObj这个函数会调用自定义对象的[key hash]这个方法 - (int)hashWithObj:(id)obj { return [obj hash] % M; //生成一个索引 } 重写isEqual的原因是 1234oc与swift 的集合与字典是基于哈希表，而哈希表是由数组+链表或者数组+搜索树(红黑树)构成的 1 为解决哈希冲突，哈希数组的每个索引对应一个链表或者红黑树 2 这个红黑树或者链表的每个节点存放key，value 3 由搜索树与链表的结构规定，其节点存放的泛型key是必须可比较的 字典、集合不能存放int等基本数据结构的原因： 显而易见，他们底层的复杂结构（红黑树，链表）的节点定义为泛型，而泛型不支持基本类型 OC版本123456789101112131415161718192021222324252627282930313233343536@interface Dog_OC : NSObject@property (nonatomic, copy ) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, strong) NSObject *other;@end@implementation Dog_OC- (NSUInteger)hash { NSUInteger calcHash = 7; calcHash = calcHash*31 + self.age; calcHash = calcHash*31 + [self.name hash]; calcHash = calcHash*31 + [self.other hash]; return calcHash;}-(BOOL)isEqual:(id)object{ if (self == object) { return YES; } if (![self isKindOfClass:[Dog_OC class]]) { return NO; } return [self isEqualDog:(Dog_OC *)object];}-(BOOL)isEqualDog:(Dog_OC *)object{ if (!object) { return NO; } BOOL isNameEqual = [self.name isEqualToString:object.name]; BOOL isAgeEqual = self.age == object.age;//比较 BOOL isOtherEqual = [self.other isEqual:object.other];//比较 return isNameEqual &amp;&amp; isAgeEqual &amp;&amp; isOtherEqual;}@end swift版本12345678910111213141516171819202122class Dog: Hashable,CustomDebugStringConvertible { var name = \"\" var age = 0 init(name:String,age:Int) { self.name = name self.age = age } static func == (lhs: Dog, rhs: Dog) -&gt; Bool { return (lhs.age - rhs.age) &gt;= 0 } var hashValue: Int { return self.name.hashValue ^ self.age.hashValue } func hash(into hasher: inout Hasher) { print(hasher) } var debugDescription: String { return \"狗名是\"+self.name+\"年龄是\\(self.age)\" }}","link":"/2018/09/17/iOS之hash与isEqual/"},{"title":"vim配置成IDE","text":"最终效果 vim插件插件管理器 Vundle1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 安装插件在shell里面运行 vim +PluginInstall +qall 配置.vimrc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270\" vundleif filereadable(expand(\"~/.vimrc.bundles\")) source ~/.vimrc.bundlesendifset nu \"开启行号set showcmd \"显示cmdset laststatus=1set magicset cursorlineset mouse=a \"启用鼠标set go=set showmatchset matchtime=1set nobackupset rulerset autoindentset confirmset tabstop=4set shiftwidth=4set smarttabset nocompatibleset expandtabset backspace=indent,eol,startset wildmenuset fo=cqrtset laststatus=2set textwidth=78set colorcolumn=+1set ww=&lt;,&gt;,h,lset noeb visualbelllet mapleader = \",\"filetype onfiletype plugin onfiletype indent onsyntax onsyntax enable\" encodingset fencs=utf-8,usc-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936set fileencoding=utf-8\" Molokaicolorscheme molokaihighlight NonText guibg=#060606highlight Folded guibg=#0A0A0A guifg=#9090D0\" some mapmap &lt;F5&gt; :call CR()&lt;CR&gt;func! CR() exec \"w\" exec \"!g++ % -o %&lt;\" exec \"! ./%&lt;\"endfuncmap &lt;F10&gt; :call RG()&lt;CR&gt;func! RG() exec \"w\" exec \"!g++ % -g -o % &lt;\" exec \"! ./%&lt;\"endfuncmap &lt;F2&gt; :call SetTitle()&lt;CR&gt;func SetTitle()let l = 0let l = l + 1 | call setline(l,'/******************************')let l = l + 1 | call setline(l,' *File name: '.expand(\"%\"))let l = l + 1 | call setline(l,' *Author: wzhzzmzzy')let l = l + 1 | call setline(l,' *Created Time: '.strftime(\"%c\"))let l = l + 1 | call setline(l,' *TODO:')let l = l + 1 | call setline(l,'******************************/')let l = l + 1 | call setline(l,'')let l = l + 1 | call setline(l,'#include &lt;cstdio&gt;')let l = l + 1 | call setline(l,'#include &lt;cstring&gt;')let l = l + 1 | call setline(l,'#include &lt;cstdlib&gt;')let l = l + 1 | call setline(l,'#include &lt;iostream&gt;')let l = l + 1 | call setline(l,'#include &lt;string&gt;')let l = l + 1 | call setline(l,'#include &lt;algorithm&gt;')let l = l + 1 | call setline(l,'#include &lt;vector&gt;')let l = l + 1 | call setline(l,'#include &lt;queue&gt;')let l = l + 1 | call setline(l,'#include &lt;set&gt;')let l = l + 1 | call setline(l,'#include &lt;map&gt;')let l = l + 1 | call setline(l,'')let l = l + 1 | call setline(l,'using namespace std;')let l = l + 1 | call setline(l,'')endfuncmap &lt;F3&gt; :call SetTitle2()&lt;CR&gt;func SetTitle2()let l = 0let l = l + 1 | call setline(l,'/******************************')let l = l + 1 | call setline(l,' *File name: '.expand(\"%\"))let l = l + 1 | call setline(l,' *Author: wzhzzmzzy')let l = l + 1 | call setline(l,' *Created Time: '.strftime(\"%c\"))let l = l + 1 | call setline(l,' *TODO:')let l = l + 1 | call setline(l,'******************************/')let l = l + 1 | call setline(l,'')let l = l + 1 | call setline(l,'#include &lt;bits/stdc++.h&gt;')let l = l + 1 | call setline(l,'using namespace std;')let l = l + 1 | call setline(l,'')endfuncset nocompatible \" 这是必需的 filetype off \" 这是必需的 \" 在此设置运行时路径 set rtp+=~/.vim/bundle/Vundle.vim\" vundle初始化 call vundle#begin()\" 或者传递一个Vundle 安装插件的路径\"call vundle#begin('~/some/path/here')\" 让 Vundle 管理 Vundle, 必须Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'\" 传递路径，合理设置运行时路径。 Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}\" vim代码补全插件 Plugin 'Valloric/YouCompleteMe'Plugin 'git://github.com/scrooloose/nerdtree.git'\"添加jedi-vim代码补全插件Plugin 'davidhalter/jedi-vim'\"python语法检测Plugin 'scrooloose/syntastic'\"添加PEP8代码风格检查Plugin 'nvie/vim-flake8'\"配色方案Plugin 'jnurmine/Zenburn'Plugin 'altercation/vim-colors-solarized'\"状态栏Plugin 'vim-airline/vim-airline'\"代码折叠插件Plugin 'tmhedberg/SimpylFold'\"buffer管理Bundle 'minibufexpl.vim'\"快速注释Bundle 'comments.vim'\"窗口管理Bundle 'winmanager' \"开启代码折叠set foldmethod=indentset foldlevel=99\"设置快捷键为空格noremap &lt;space&gt; za\"显示折叠代码的文档字符串let g:SimpylFold_docstring_preview=1\"每个插件都应该在这一行之前 call vundle#end() \" 这是必需的 filetype plugin indent on \" 这是必需的 \" To ignore plugin indent changes, instead use:\"filetype plugin on\"\" Brief help\" :PluginList - lists configured plugins\" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate\" :PluginSearch foo - searches for foo; append `!` to refresh local cache\" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal\"\" see :h vundle for more details or wiki for FAQ\" Put your non-Plugin stuff after this line\"\"\"启用NERDTreeautocmd vimenter * NERDTree\" Nerd Treelet NERDChristmasTree=0let NERDTreeWinSize=40let NERDTreeChDirMode=2let NERDTreeIgnore=['\\~$', '\\.pyc$', '\\.swp$']let NERDTreeShowBookmarks=1let NERDTreeWinPos=\"left\"autocmd vimenter * if !argc() | NERDTree | endif autocmd bufenter * if (winnr(\"$\") == 1 &amp;&amp; exists(\"b:NERDTreeType\") &amp;&amp; b:NERDTreeType == \"primary\") | q | endifnmap &lt;F6&gt; :NERDTreeToggle&lt;CR&gt;\" winmanager配置let g:NERDTree_title='NERD Tree'let g:winManagerWindowLayout='NERDTree|TagList'function! NERDTree_Start() exec 'NERDTree'endfunctionfunction! NERDTree_IsValid() return 1endfunction\" 绑定F2到winmanagernmap &lt;silent&gt; &lt;F2&gt; :WMToggle&lt;CR&gt;\" 绑定F8快捷键\" 使用winmanager时，不使用快捷键\" nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;\" 启动Vim后，自动打开taglist窗口。\" 使用winmanager时，将自动打开窗口关闭let Tlist_Auto_Open = 0\" Tagbarlet g:tagbar_width=35let g:tagbar_autofocus=1nmap &lt;F7&gt; :TagbarToggle&lt;CR&gt;\" YouCompleteMe\" 寻找全局配置文件let g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py'\" 禁用syntastic来对python检查let g:syntastic_ignore_files=[\".*\\.py$\"] \" 使用ctags生成的tags文件let g:ycm_collect_identifiers_from_tag_files = 1\" 开启语义补全\" 修改对C语言的补全快捷键，默认是CTRL+space，修改为ALT+;未测出效果\"let g:ycm_key_invoke_completion = '&lt;M-;&gt;'\" 设置转到定义处的快捷键为ALT+G，未测出效果\"nmap &lt;M-g&gt; :YcmCompleter GoToDefinitionElseDeclaration &lt;C-R&gt;=expand(\"&lt;cword&gt;\")&lt;CR&gt;&lt;CR&gt; \"关键字补全\"let g:ycm_seed_identifiers_with_syntax = 1\" 在接受补全后不分裂出一个窗口显示接受的项set completeopt-=preview\" 让补全行为与一般的IDE一致set completeopt=longest,menu\" 不显示开启vim时检查ycm_extra_conf文件的信息let g:ycm_confirm_extra_conf=0\" 每次重新生成匹配项，禁止缓存匹配项let g:ycm_cache_omnifunc=0\" 在注释中也可以补全let g:ycm_complete_in_comments=1\" 输入第一个字符就开始补全let g:ycm_min_num_of_chars_for_completion=1\" 错误标识符let g:ycm_error_symbol='&gt;&gt;'\" 警告标识符let g:ycm_warning_symbol='&gt;*'\" 不查询ultisnips提供的代码模板补全，如果需要，设置成1即可\" let g:ycm_use_ultisnips_completer=0\"\"\"设置主题颜色，以及设置快捷键F5if has('gui_running') set background=dark colorscheme solarizedelse colorscheme zenburnendifcall togglebg#map(\"&lt;F5&gt;\")\"开启代码折叠set foldmethod=indentset foldlevel=99\"设置快捷键为空格noremap &lt;space&gt; za\"显示折叠代码的文档字符串let g:SimpylFold_docstring_preview=1","link":"/2019/05/09/vim配置成IDE/"},{"title":"学习Java一:Java类的加载机制","text":"创建一个继承类观察其加载顺序创建一个SupClass的父类1234567891011121314151617181920212223242526272829/* 父类 */public class SupClass { /* 父类的静态属性 */ private final static String staticAttr = \"我是父类的静态属性\"; /* 父类的属性 */ private String arrt = \"我是父类的属性\"; /* 父类的构造方法 */ public SupClass() { System.out.println(\"我执行的是父类的构造方法\"); } /* 父类的方法 */ void method() { System.out.println(\"我执行的是父类的普通方法\"); } /* 父类的静态方法 */ static void staticMethod() { System.out.println(\"我执行的是父类的静态方法\"); } /* 父类的代码块 */ { System.out.println(arrt); method(); } /* 父类的静态代码块 */ static { System.out.println(staticAttr); staticMethod(); }} 创建一个SubClass的子类123456789101112131415161718192021222324252627282930/* 子类 */public class SubClass extends SupClass { /* 子类的静态属性 */ private final static String staticAttr = \"我是子类的静态属性\"; /* 子类的属性 */ private String arrt = \"我是子类的属性\"; /* 子类的是构造方法 */ public SubClass() { System.out.println(\"我执行的是子类的构造方法\"); } /* 子类的方法 */ void method() { System.out.println(\"我执行的是子类的普通方法\"); } /* 子类的静态方法 */ static void staticMethod() { System.out.println(\"我执行的是子类的静态方法\"); } /* 之类的代码块 */ { System.out.println(arrt); method(); } /* 子类的静态代码块 */ static { System.out.println(staticAttr); staticMethod(); }} 创建子类对象，观察调用顺序12345public class App { public static void main(String[] args) { SubClass subClass = new SubClass(); }} 打印结果12345678910我是父类的静态属性我执行的是父类的静态方法我是子类的静态属性我执行的是子类的静态方法我是父类的属性我执行的是子类的普通方法我执行的是父类的构造方法我是子类的属性我执行的是子类的普通方法我执行的是子类的构造方法 分析其结果 加载父类 父类会产生自己的静态空间 属性 方法 块、 执行静态代码块 加载子类 子类会产生自己的静态空间 属性 方法 块、 执行静态代码块 开辟对象空间 加载父类非静态资源 属性 方法 块 执行代码块 加载子类非静态资源 属性 方法 块 执行代码块 将对象空间的地址引用交给 变量来引用 草图","link":"/2019/05/12/学习Java一-Java类的加载机制/"},{"title":"关系数据库Mysql","text":"安装和配置（以CentOS Linux环境为例）使用安装命令 ：yum -y install mysql mysql-server mysql-devel安装完成却发现Myserver安装缺失，在网上找原因，原来是因为CentOS 7上把MySQL从默认软件列表中移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接， 下载并安装MySQL官方的Yum Repositorywget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 使用上面的命令直接安装Yum Repositoryyum -y install mysql57-community-release-el7-10.noarch.rpm 安装MySQL服务器yum -y install mysql-community-server 可以使用下面的命令查看已经安装的MySQL相关的包。 1rpm -qa | grep mysql 启动MySQL服务。 先修改MySQL的配置文件（/etc/my.cnf）添加一行skip-grant-tables，可以设置不进行身份验证即可连接MySQL服务器，然后就可以以超级管理员（root）身份登录。 1vim /etc/my.cnf 12345678910[mysqld]skip-grant-tablesdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socksymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 接下来可以使用下面的命令来启动MySQL。 1service mysqld start 在CentOS 7中建议使用下面的命令来启动MySQL。 1systemctl start mysqld 使用MySQL客户端工具连接服务器。 命令行工具： 1mysql -u root 修改超级管理员（root）的访问口令为i_LOVE_macos_123。 123use mysql;update user set authentication_string=password('i_LOVE_macos_123') where user='root';flush privileges; 将MySQL配置文件中的skip-grant-tables去掉，然后重启服务器，重新登录。这一次需要提供用户名和口令才能连接MySQL服务器。 12systemctl restart mysqldmysql -u root -p 也可以选择图形化的客户端工具来连接MySQL服务器，可以选择下列工具之一： MySQL Workbench（官方提供的工具） Navicat for MySQL（界面简单优雅，功能直观强大） SQLyog for MySQL（强大的MySQL数据库管理员工具） 常用命令。 查看服务器版本。 1select version(); 查看所有数据库。 1show databases; 切换到指定数据库。 1use mysql; 查看数据库下所有表。 1show tables; 获取帮助。在mysql&gt;执行 1234567? contents;? functions;? numeric functions;? round;? data types;? longblob; MySQL相关知识存储引擎 InnoDB MyISAM 数据类型索引索引的类型 B-Tree索引 HASH索引 R-Tree索引（空间索引） Full-text索引（全文索引） 视图查询的快照，可以将访问权限控制到列上。 12create view ... as select ...drop view ... 存储过程123456create procedure ... (params)begin...end;call ... 1cursor.callproc('...') 触发器不能用，因为多个行锁可能直接升级为表锁，导致性能低下。 事务控制SQL注入攻击数据分区SQL优化优化步骤 通过show status了解各种SQL的执行频率。 1234show status like 'com_%';show status like 'innodb_%';show status like 'connections';show status like 'slow_queries'; 定位低效率的SQL语句 - 慢查询日志。 1show processlist 通过explain了解SQL的执行计划。 select_type：查询类型（simple、primary、union、subquery） table：输出结果集的表 type：访问类型（ALL、index、range、ref、eq_ref、const、NULL） possible_keys：查询时可能用到的索引 key：实际使用的索引 key_len：索引字段的长度 rows：扫描的行数 extra：额外信息 通过show profiles和show profile for query分析SQL。 SQL优化 优化insert语句 优化order by语句 优化group by语句 优化嵌套查询 优化or条件 优化分页查询 使用SQL提示 USE INDEX IGNORE INDEX FORCE INDEX 配置优化 调整max_connections 调整back_log 调整table_open_cache 调整thread_cache_size 调整innodb_lock_wait_timeout 架构优化 通过拆分提高表的访问效率 垂直拆分 水平拆分 逆范式理论 数据表设计的规范程度称之为范式（Normal Form） 1NF：列不能再拆分 2NF：所有的属性都依赖于主键 3NF：所有的属性都直接依赖于主键（消除传递依赖） BCNF：消除非平凡多值依赖 使用中间表提高统计查询速度 数据备份导入和导出 select … into outfile … load data infile … into table … mysqldump mysqlimport ibbackup工具xtrabackup工具主从复制集群","link":"/2018/09/19/关系数据库Mysql/"},{"title":"博客入门","text":"欢迎使用 GuoTZ 版 博客博客 所使用的 Markdown 语法为 Github Flavored Markdown，简称 GFM，这是一种最为广泛使用的 Markdown 语法之一。如果你不知道什么是 Markdown，建议看一下附带的 Markdown 语法官方说明 文档。GFM 除了支持官方的语法外，还扩展了不少语法。 GuoTZ 版 博客 的主要界面和功能1[Markdown 语法官方说明](Markdown Syntax.md) Markdown 语法官方说明 1![展示图片](http://uploads.scratch.mit.edu/projects/thumbnails/120894657.png) 回车转为换行官方的语法规定结尾加 2 个以上空格加换行才会转成换行，也就是 &lt;br /&gt; 标签。MWeb 中有个选项可以直接把换行转成 &lt;br /&gt;，不用加上 2 个以上空格，这个选项默认是开启的。如果要关闭，请在设置页面关闭。 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片大小及对齐官方和 GFM 都不支持图片大小控制及对齐设置。 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) }} 效果如下： 123456function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) }} 这个语法目前在 博客 中使用，必须前后空一行，才会正确解析。我觉得，在写 Markdown 文档过程中，运用空行很有必要，基本上，块级元素（标题、列表、引用、代码块、表格、段落等），都建议前后空一行。 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： ~~删除这些~~ 效果如下： 加删除线像这样用： 删除这些 LaTeXMarkdown 语法： 12345678块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（在设置页面中启用 LaTeX 才会看到效果，默认为启用）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 注 阅读更多的功能只用在文档库生成静态网站或发布到 Wordpress 博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC] markdown语法高亮 Apache Bash C# C++ CSS CoffeeScript Diff HTML, XML HTTP Ini, TOML JSON Java JavaScript Makefile Markdown Nginx Objective-C PHP Perl Properties Python Ruby SQL Shell Session Other Swift TP agger Script TypeScript VB.NET Vim new “算法-：排序算法”servergeneratedeploy","link":"/2016/12/12/博客入门/"},{"title":"centos下搭建svn","text":"centos7 Linuxsvn安装配置 安装svn yum -y install subversion 创建svn根文件夹mkdir /var/svns 配置文件夹 123vim /etc/sysconfig/svnserve#文件内容OPTIONS=\"-r /var/svns\" svn创建版本库 创建svn版本库svnadmin create /var/svns/xxxx 1234#版本库的conf文件夹authz：#负责账号权限的管理，控制账号是否读写权限passwd：#负责账号和密码的用户名单管理svnserve.conf：#svn服务器配置文件 vim svnserve.conf 12345anon-access = none #表示禁止匿名用户访问。auth-access = write #表示授权用户拥有读写权限。password-db = passswd #指定用户名口令文件，即 passwd 文件。authz-db = authz #指定权限配置文件，即 authz 文件。realm = /var/svnrepos #指定认证域，即 /var/svnrepos 目录。 vim passwd 12[users] #下面添加admin = rw #设置读写权限 vim authz 12[/]admin = password #账号密码 svn命令控制123killall svnserve #杀掉svn进程svnserve -d -r /var/svns #启动svnps -ef | grep svn #看服务启动是否成功 mac地址测试 svn co svn://ip地址:3690/xxxx centos7 防火墙开放svn通过12firewall-cmd --permanent --add-port=3690/tcpsystemctl restart firewalld","link":"/2017/01/27/centos下搭建svn/"},{"title":"数据结构","text":"线性数据结构数组定义栈定义栈的功能协议接口数组栈用数组实现栈结构数组栈的使用链表栈用链表实现栈结构链表栈的使用队列定义队列的功能协议接口数组队列用数组实现队列结构数组队列的使用循环队列用数组循环实现队列结构链表队列用链表实现队列结构链表栈的使用分析链表队列链表队列优化链表定义链表的结构链表的实现链表的增链表的改链表的查链表的删链表的使用二分搜索树定义二分搜索树的结构二分搜索树的实现二分搜索树查询某节点二分搜索树的遍历前序遍历中序遍历后序遍历非递归前序遍历栈层序遍历队列集合的底层实现 链表实现集合 二分搜索树集合 映射 map 字典 dict底层实现 链表实现 二分搜索数实现 二叉堆 优先队列 结构 入 出 二叉堆 O㏒n O㏒n 顺序线性结构 O1 On 普通线性结构 On O1 线段树 Tire字典树并查集平衡树和AVL红黑树哈希表","link":"/2017/09/12/数据结构/"},{"title":"数据结构之二分搜索树","text":"二分搜索树swift代码 定义二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点（no duplicate nodes）。 二分搜索树的结构123456789101112131415161718/// 元查找树的节点class Node&lt;E&gt;:CustomDebugStringConvertible { ///数据域 public var e:E /// 左子树 public var left: Node&lt;E&gt;? /// 右子树 public var right: Node&lt;E&gt;? init(e:E) { self.e = e self.left = nil self.right = nil } var debugDescription: String { return \"\\(e)\" }} 二分搜索树的实现123456789101112131415161718192021222324/// 二分搜索树的数据是具有比较性的class BST&lt;E&gt;:CustomDebugStringConvertible where E:Comparable { private var root:Node&lt;E&gt;? private var size:Int init() { self.size=0 self.root=nil } public func getSize() -&gt; Int { return self.size } public func isEmpty() -&gt; Bool{ return self.size == 0; } var debugDescription: String { return \"\" } } 二分搜索树的添加节点1234567891011121314151617181920// 向二分搜索树中添加新的元素epublic func add(e:E){ root = add(node: self.root, e: e) }// 向以node为根的二分搜索树中插入元素e，递归算法private func add(node:Node&lt;E&gt;?, e:E) -&gt; Node&lt;E&gt;?{ if node == nil { size += 1 return Node.init(e: e) } if e &lt; node!.e { node?.left = add(node: node?.left, e: e) } else if e &gt; node!.e { node?.right = add(node: node?.right, e: e) } return node} 二分搜索树查询某节点1234567891011121314151617181920// 看二分搜索树中是否包含元素epublic func contains(e:E) -&gt; Bool{ return self.contains(node: root, e: e)}// 看以node为根的二分搜索树中是否包含元素e, 递归算法private func contains(node:Node&lt;E&gt;?, e:E) -&gt; Bool{ if node==nil { return false; } if e == node!.e { return true } else if e &lt; node!.e { return contains(node: node?.left, e: e) } else { return contains(node: node?.right, e: e) }} 二分搜索树的遍历前序遍历123456789101112131415// 二分搜索树的前序遍历public func preOrder(){ self.preOrder(node: self.root);}// 前序遍历以node为根的二分搜索树, 递归算法private func preOrder(node:Node&lt;E&gt;?){ if node==nil { return } print(node!.e); self.preOrder(node: node!.left); self.preOrder(node: node!.right);} 中序遍历中序及由小到大的排序12345678910111213141516// 二分搜索树的中序遍历//大小顺序排列public func inOrder(){ self.inOrder(node: self.root);}// 中序遍历以node为根的二分搜索树选左再根再右节点, 递归算法private func inOrder(node:Node&lt;E&gt;?){ if node==nil { return } self.inOrder(node: node!.left); print(node!.e); self.inOrder(node: node!.right);} 后序遍历12345678910111213/// 后序遍历public func postOrder() { self.postOrder(node: self.root)}private func postOrder(node:Node&lt;E&gt;?) { if node == nil { return } self.postOrder(node: node?.left) self.postOrder(node: node?.right) print(node!.e)} 非递归前序遍历利用栈结构实现递归栈的结构1234567891011121314151617// 二分搜索树的非递归前序遍历public func preOrderNR(){ let stack = ListStack&lt;Node&lt;E&gt;&gt;(); stack.push(e: root!); while(!stack.isEmpty()){ let cur = stack.pop(); print(\"\\(String(describing: (cur?.e)!))\"); if(cur?.right != nil){ stack.push(e: (cur?.right)!); } if(cur?.left != nil){ stack.push(e: (cur?.left)!); } }} 层序遍历利用队列的先进选出的原理，从跟节点遍历搜索树，依次将该节点的左右子树加入队列中，每处理完一个节点后都将其左右子树加入队列即可，**知道左右子树为nil**1234567891011121314151617181920// 二分搜索树的层序遍历public func levelOrder(){ let q = ListQueue&lt;Node&lt;E&gt;&gt;(); if self.root==nil { return } q.enqueue(e: self.root!) while(!q.isEmpty()){ let cur = q.dequeue() print(\"\\(String(describing: (cur?.e)!))\") if(cur?.left != nil){ q.enqueue(e: (cur?.left)!) } if(cur?.right != nil){ q.enqueue(e: (cur?.right)!) } }} 搜索树的使用1234567891011121314151617var bst = BST&lt;Int&gt;()//var list = [1,4,6,2,3,4,55,67,8,9,10]var list = [11,21,23,20,5,6,7,8,9,3,11,12,4,14,15,16,17,18,19]for i in list { bst .add(e: i)}print(\"-------前序-----------\")bst.preOrder()print(\"-------非递归前序-----------\")bst.preOrderNR()print(\"-------层序-----------\")bst.levelOrder()print(\"-------中序-----------\")bst.inOrder()print(\"-------后序-----------\")bst.postOrder() 上面代码产生的二分搜索树的结构如下其打印结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Hello, World!-------前序-----------11534678921201214151617181923-------非递归前序-----------11534678921201214151617181923-------层序-----------11521362023471281491516171819-------中序-----------34567891112141516171819202123-------后序-----------43987651918171615141220232111Program ended with exit code: 0","link":"/2017/10/01/数据结构之二分搜索树/"},{"title":"数据结构之哈希表","text":"Hash表也称散列表，也有直接译作哈希表Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。 哈希函数对比之前的搜索树，它们的查找都是先从根节点进行查找，从节点取出数据或索引与查找值进行比较。那么，有没有一种函数H，根据这个函数和查找关键字key，可以直接确定查找值所在位置，而不需要一个个比较。这样就预先知道key所在的位置，直接找到数据，提升效率。即地址index=H（key）说白了，hash函数就是根据key计算出应该存储地址的位置，而哈希表是基于哈希函数建立的一种查找表 哈希函数的构造方法根据前人经验，统计出如下几种常用hash函数的构造方法： 直接定制法哈希函数为关键字的线性函数如 H（key）=a*key+b!这种构造方法比较简便，均匀，但是有很大限制，仅限于地址大小=关键字集合的情况 数字分析法假设关键字集合中的每个关键字key都是由s位数字组成（k1,k2,……,knk1,k2,……,kn）,分析key中的全体数据，并从中提取分布均匀的若干位或他们的组合构成全体 平方取中法如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。 折叠法如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址 除留余数法用的较多 取模法H（key）=key MOD p （p&lt;=m m为表长）一边来说模一个质素首先来说假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。 hash函数设计的考虑因素 计算散列地址所需要的时间（即hash函数本身不要太复杂） 关键字的长度 表长 关键字分布是否均匀，是否有规律可循 设计的hash函数在满足以上条件的情况下尽量减少冲突 哈希冲突1234即不同key值产生相同的地址，H（key1）=H（key2） 比如我们上面说的存储3 6 9，p取3是 3 MOD 3 == 6 MOD 3 == 9 MOD 3 此时3 6 9都发生了hash冲突 哈希冲突的解决方案不管hash函数设计的如何巧妙，总会有特殊的key导致hash冲突，特别是对动态查找表来说。hash函数解决冲突的方法有以下几个常用的方法 开放定制法 链地址法 公共溢出区法建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。 再散列法准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……重点了解一下开放定制法和链地址法 链地址法产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据 模 lwr upr % err prime 2^5 2^6 10.416667 53 2^6 2^7 1.041667 97 2^7 2^8 0.520833 193 2^8 2^9 1.302083 389 2^9 2^10 0.130208 769 2^10 2^11 0.455729 1543 2^11 2^12 0.227865 3079 2^12 2^13 0.113932 6151 2^13 2^14 0.008138 12289 2^14 2^15 0.069173 24593 2^15 2^16 0.010173 49157 2^16 2^17 0.013224 98317 2^17 2^18 0.002543 196613 2^18 2^19 0.006358 393241 2^19 2^20 0.000127 786433 2^20 2^21 0.000318 1572869 2^21 2^22 0.000350 3145739 2^22 2^23 0.000207 6291469 2^23 2^24 0.000040 12582917 2^24 2^25 0.000075 25165843 2^25 2^26 0.000010 50331653 2^26 2^27 0.000023 100663319 2^27 2^28 0.000009 201326611 2^28 2^29 0.000001 402653189 2^29 2^30 0.000011 805306457 2^30 2^31 0.000000 1610612741","link":"/2018/09/11/数据结构之哈希表/"},{"title":"数据结构之哈希表实现1+链表","text":"基于两个线性结构构建哈希表数组+链表代码地址 实现带有键值对的链表123456789101112131415161718192021222324252627/// 链表的节点class Node&lt;K,V&gt;:CustomDebugStringConvertible { var key:K? var value:V? var node:Node&lt;K,V&gt;? init(key:K?,value:V?, node:Node&lt;K,V&gt;?) { self.key = key self.value = value self.node = node } init() { self.key = nil self.value = nil self.node = nil } var debugDescription: String { var keyStr = \"nil\" if let key = self.key { keyStr = \"\\\"\\(key)\\\"\" } var vStr = \"nil\" if let v = self.value { vStr = \"\\\"\\(v)\\\"\" } return keyStr+\":\"+vStr }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/// 每个节点存放key，value的链表class LinkedList&lt;K,V&gt;:CustomDebugStringConvertible where K:Equatable { private var dummyHead:Node&lt;K,V&gt; private var size:Int init(){ self.dummyHead = Node&lt;K,V&gt;() self.size = 0 } // 获取链表中的元素个数 public func getSize()-&gt;Int{ return size } // 返回链表是否为空 public func isEmpty()-&gt;Bool{ return size == 0 } /// 查找key对应的节点 /// /// - Parameter key: key description /// - Returns: return value description private func getNode(key:K) -&gt; Node&lt;K, V&gt;? { var cur:Node&lt;K,V&gt;? = self.dummyHead.node while cur != nil { if let curKey = cur?.key { if curKey == key { return cur } } cur = cur?.node } return nil } /// 添加键值对 /// /// - Parameters: /// - key: key description /// - value: value description func add(key:K,value:V) { let node = getNode(key: key) if node == nil { self.dummyHead.node = Node&lt;K,V&gt;.init(key: key, value: value, node: self.dummyHead.node) self.size += 1 } else { node?.value = value } } /// 查询key是否存在 /// /// - Parameter key: key description /// - Returns: return value description func contains(key:K) -&gt; Bool { return (self.getNode(key: key) != nil) } /// 查询key对应的value /// /// - Parameter key: key description /// - Returns: return value description func get(key:K) -&gt; V? { return self.getNode(key: key)?.value } /// 获取所有的key /// /// - Returns: return value description func allKeys() -&gt; [K]? { var list:Array&lt;K&gt; = [] var prev:Node&lt;K,V&gt;? = self.dummyHead; while(prev?.node != nil){ if let nodeKey = prev?.node?.key { list.append(nodeKey) } prev = prev?.node } return list } /// 设置简直对吗 /// /// - Parameters: /// - key: key description /// - value: value description func set(key:K,value:V){ let node = self.getNode(key: key) if node==nil { return } node?.value = value } /// 移除key对应的节点 /// /// - Parameter key: key description /// - Returns: return value description func remove(key:K) -&gt; V? { var prev:Node&lt;K,V&gt;? = self.dummyHead; while(prev?.node != nil){ if let nodeKey = prev?.node?.key { if (nodeKey == key) { break; } } prev = prev?.node } if(prev?.node != nil){ let delNode = prev?.node prev?.node = delNode?.node delNode?.node = nil size -= 1 return delNode?.value } return nil } var debugDescription: String { var str = \"{\" var node:Node&lt;K,V&gt;? = self.dummyHead for _ in 0..&lt;self.getSize() { node = node?.node if let nodeNoNull = node { str.append(\"\\(String(describing: nodeNoNull))\" + \",\") } } return str+\"}\" }} 实现哈希表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/// 哈希表 k必须x实现 Hashable协议/// 实现Hashable的哈希值hashValue/// Equatable 实现 == isEqualclass HashTable&lt;K,V&gt;:CustomDebugStringConvertible where K :Hashable { private let capacitys = [53,97,193,389,769,1543,3079,6151,12289,24593,49157,98317,196613,393241,786433,1572869,3145739, 6291469,12582917,25165843,50331653,100663319,201326611,402653189,805306457,1610612741,] /// 平均每个索引哈希冲突的上限值 private let upperTol = 10 /// 平均每个索引哈希冲突的下限值 private let lowerTol = 2 private let initCapacity = 7 private var lienkedTables: Array&lt;LinkedList&lt;K,V&gt;&gt; private var size:Int private var M:Int private var capacityIndex:Int = 0 init() { self.M = capacitys[self.capacityIndex] self.size = 0 self.lienkedTables = Array&lt;LinkedList&lt;K,V&gt;&gt;() for _ in 0..&lt;M { self.lienkedTables.append(LinkedList&lt;K,V&gt;()) } } func getSize() -&gt; Int { return self.size } /// 哈希函数 /// /// - Parameter key: key description /// - Returns: return value description func hash(key:K) -&gt; Int { // 对key的哈希值转成正数 再取模 return (key.hashValue &amp; 0x7fffffff) % M } func add(key:K,value:V) { /// 再哈希表里面获取对key哈希处理后的链表 let linked = self.lienkedTables[hash(key: key)] if linked.contains(key: key) { //如果链表中存在key对应的节点 linked.set(key: key, value: value) } else { linked.add(key: key, value: value) size += 1; /// 用静态数组实现时进行扩容 if self.size &gt;= self.upperTol*M &amp;&amp; capacityIndex + 1 &lt; capacitys.count { capacityIndex += 1 self.resize(newM: self.capacitys[self.capacityIndex]) } } } func set(key:K,value:V) { /// 再哈希表里面获取对key哈希处理后的链表 let linked = self.lienkedTables[hash(key: key)] if linked.contains(key: key) { linked.set(key: key, value: value) } } /// 判断哈希表中是否存在key /// /// - Parameter key: key description /// - Returns: return value description func contains(key:K) -&gt; Bool { return self.lienkedTables[self.hash(key: key)].contains(key: key) } /// 获取某个key对应的value /// /// - Parameter key: key description /// - Returns: return value description func get(key:K) -&gt; V? { return self.lienkedTables[self.hash(key: key)].get(key: key) } /// 删除某个键值对 /// /// - Parameter key: key description /// - Returns: return value description func remove(key:K) -&gt; V? { /// 再哈希表里面获取对key哈希处理后的链表 let linked = self.lienkedTables[hash(key: key)] var data:V? if linked.contains(key: key) { data = linked.remove(key: key) self.size -= 1 /// 用静态数组实现时进行缩容 if self.size &lt; self.lowerTol*M &amp;&amp; capacityIndex - 1 &gt; 0 { capacityIndex -= 1 self.resize(newM: self.capacitys[self.capacityIndex]) } } return data } var debugDescription: String { var str = \"[\" for item in self.lienkedTables { str.append(item.debugDescription+\",\\n\") } return str + \"]\" } func resize(newM:Int) { print(\"开始扩展容量----\\(newM)\") var newLienkedTables=Array&lt;LinkedList&lt;K,V&gt;&gt;() for _ in 0..&lt;newM { newLienkedTables.append(LinkedList&lt;K,V&gt;()) } let oleM = self.M self.M = newM for i in 0..&lt;oleM { let map = self.lienkedTables[i] for key in map.allKeys() ?? [] { if let v = map.get(key: key) { newLienkedTables[hash(key: key)].add(key: key, value: v) } } } self.lienkedTables = newLienkedTables }} 哈希表的使用12345678910111213141516171819202122232425262728293031323334353637383940class Dog: Hashable,CustomDebugStringConvertible { var name = \"\" var age = 0 init(name:String,age:Int) { self.name = name self.age = age } static func == (lhs: Dog, rhs: Dog) -&gt; Bool { return (lhs.age - rhs.age) &gt;= 0 } var hashValue: Int { return self.name.hashValue ^ self.age.hashValue } func hash(into hasher: inout Hasher) { print(hasher) } var debugDescription: String { return \"狗名是\"+self.name+\"年龄是\\(self.age)\" }}var ht = HashTable&lt;Dog,Int&gt;()for i in 0...100 { let dog = Dog(name: \"张\\(i)\", age: i) ht.add(key: dog, value: i)}print(ht)for i in 0...1000000 { let dog = Dog(name: \"TString\\(i)\", age: i) ht.add(key: dog, value: i)}print(\"当前哈希表的大小\\(ht.getSize())\") 三方用例打印的结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[ {\"狗名是张86年龄是86\":\"86\",\"狗名是张31年龄是31\":\"31\",}, {\"狗名是张88年龄是88\":\"88\",\"狗名是张36年龄是36\":\"36\",}, {\"狗名是张58年龄是58\":\"58\",}, {\"狗名是张54年龄是54\":\"54\",\"狗名是张51年龄是51\":\"51\",\"狗名是张48年龄是48\":\"48\",}, {\"狗名是张94年龄是94\":\"94\",}, {\"狗名是张34年龄是34\":\"34\",}, {\"狗名是张45年龄是45\":\"45\",}, {\"狗名是张3年龄是3\":\"3\",}, {\"狗名是张74年龄是74\":\"74\",\"狗名是张62年龄是62\":\"62\",}, {\"狗名是张38年龄是38\":\"38\",\"狗名是张16年龄是16\":\"16\",}, {\"狗名是张0年龄是0\":\"0\",}, {\"狗名是张70年龄是70\":\"70\",\"狗名是张68年龄是68\":\"68\",\"狗名是张5年龄是5\":\"5\",}, {\"狗名是张18年龄是18\":\"18\",}, {\"狗名是张92年龄是92\":\"92\",}, {\"狗名是张52年龄是52\":\"52\",}, {\"狗名是张99年龄是99\":\"99\",\"狗名是张91年龄是91\":\"91\",\"狗名是张60年龄是60\":\"60\",\"狗名是张22年龄是22\":\"22\",}, {\"狗名是张93年龄是93\":\"93\",\"狗名是张82年龄是82\":\"82\",\"狗名是张42年龄是42\":\"42\",}, {\"狗名是张50年龄是50\":\"50\",\"狗名是张19年龄是19\":\"19\",}, {\"狗名是张89年龄是89\":\"89\",\"狗名是张72年龄是72\":\"72\",\"狗名是张59年龄是59\":\"59\",\"狗名是张39年龄是39\":\"39\",}, {\"狗名是张84年龄是84\":\"84\",\"狗名是张71年龄是71\":\"71\",\"狗名是张44年龄是44\":\"44\",\"狗名是张2年龄是2\":\"2\",}, {}, {\"狗名是张75年龄是75\":\"75\",\"狗名是张47年龄是47\":\"47\",\"狗名是张43年龄是43\":\"43\",\"狗名是张17年龄是17\":\"17\",}, {\"狗名是张64年龄是64\":\"64\",\"狗名是张32年龄是32\":\"32\",}, {\"狗名是张100年龄是100\":\"100\",\"狗名是张41年龄是41\":\"41\",\"狗名是张10年龄是10\":\"10\",\"狗名是张8年龄是8\":\"8\",}, {\"狗名是张69年龄是69\":\"69\",\"狗名是张49年龄是49\":\"49\",\"狗名是张28年龄是28\":\"28\",\"狗名是张25年龄是25\":\"25\",}, {\"狗名是张96年龄是96\":\"96\",\"狗名是张78年龄是78\":\"78\",\"狗名是张13年龄是13\":\"13\",}, {\"狗名是张85年龄是85\":\"85\",}, {\"狗名是张95年龄是95\":\"95\",\"狗名是张67年龄是67\":\"67\",}, {\"狗名是张83年龄是83\":\"83\",\"狗名是张53年龄是53\":\"53\",\"狗名是张4年龄是4\":\"4\",}, {\"狗名是张24年龄是24\":\"24\",}, {\"狗名是张79年龄是79\":\"79\",\"狗名是张66年龄是66\":\"66\",\"狗名是张46年龄是46\":\"46\",}, {\"狗名是张33年龄是33\":\"33\",\"狗名是张20年龄是20\":\"20\",}, {\"狗名是张26年龄是26\":\"26\",}, {}, {\"狗名是张81年龄是81\":\"81\",\"狗名是张30年龄是30\":\"30\",}, {}, {\"狗名是张76年龄是76\":\"76\",}, {}, {\"狗名是张7年龄是7\":\"7\",\"狗名是张6年龄是6\":\"6\",}, {\"狗名是张65年龄是65\":\"65\",\"狗名是张40年龄是40\":\"40\",\"狗名是张29年龄是29\":\"29\",\"狗名是张14年龄是14\":\"14\",\"狗名是张12年龄是12\":\"12\",}, {\"狗名是张90年龄是90\":\"90\",\"狗名是张77年龄是77\":\"77\",\"狗名是张37年龄是37\":\"37\",\"狗名是张15年龄是15\":\"15\",}, {\"狗名是张80年龄是80\":\"80\",\"狗名是张63年龄是63\":\"63\",\"狗名是张57年龄是57\":\"57\",\"狗名是张27年龄是27\":\"27\",}, {\"狗名是张56年龄是56\":\"56\",}, {\"狗名是张73年龄是73\":\"73\",}, {}, {}, {\"狗名是张55年龄是55\":\"55\",}, {\"狗名是张98年龄是98\":\"98\",\"狗名是张87年龄是87\":\"87\",\"狗名是张11年龄是11\":\"11\",\"狗名是张1年龄是1\":\"1\",}, {\"狗名是张21年龄是21\":\"21\",\"狗名是张9年龄是9\":\"9\",}, {\"狗名是张23年龄是23\":\"23\",}, {}, {\"狗名是张97年龄是97\":\"97\",}, {\"狗名是张61年龄是61\":\"61\",\"狗名是张35年龄是35\":\"35\",},]开始扩展容量----97开始扩展容量----193开始扩展容量----389开始扩展容量----769开始扩展容量----1543开始扩展容量----3079开始扩展容量----6151开始扩展容量----12289开始扩展容量----24593开始扩展容量----49157开始扩展容量----98317开始扩展容量----196613Program ended with exit code: 0","link":"/2018/09/18/数据结构之哈希表实现1-链表/"},{"title":"数据结构之二分搜索树2","text":"数据结构之二分搜索树2查找最值查找最小值1234567891011121314151617181920// 寻找二分搜索树的最小元素public func minimum() -&gt;E?{ if(size == 0){ return nil } let minNode = minimum(node: self.root); return minNode?.e;}// 返回以node为根的二分搜索树的最小值所在的节点private func minimum(node:Node&lt;E&gt;?) -&gt; Node&lt;E&gt;?{ if node == nil { return nil } if( node!.left == nil ){ return node } return minimum(node: node?.left);} 查找最大值1234567891011121314151617181920// 寻找二分搜索树的最da元素public func maxmum() -&gt;E?{ if(size == 0){ return nil } let minNode = maxmum(node: self.root); return minNode?.e;}// 返回以node为根的二分搜索树的最大值所在的节点private func maxmum(node:Node&lt;E&gt;?) -&gt; Node&lt;E&gt;?{ if node == nil { return nil } if( node!.left == nil ){ return node } return minimum(node: node?.right);} 调试123456789101112var bst = BST&lt;Int&gt;()//var list = [1,4,6,2,3,4,55,67,8,9,10]var list = [11,21,23,20,5,6,7,8,9,3,11,12,4,14,15,16,17,18,19]for i in list { bst .add(e: i)}print(\"-------mini-----------\")print(bst.minimum())print(\"-------max-----------\")print(bst.maxmum()) 12345-------mini-----------3-------max-----------23Program ended with exit code: 0 删除最值删除最小值1234567891011121314151617181920212223// 从二分搜索树中删除最小值所在节点, 返回最小值public func removeMin() -&gt;E?{ let ret = minimum(); root = removeMin(node: root); return ret;}// 删除掉以node为根的二分搜索树中的最小节点// 返回删除节点后新的二分搜索树的根private func removeMin(node:Node&lt;E&gt;?)-&gt;Node&lt;E&gt;?{ if node == nil { return nil } if(node!.left == nil){ let rightNode = node?.right; node!.right = nil; size -= 1; return rightNode; } node!.left = removeMin(node: node!.left); return node;} 删除最大值1234567891011121314151617181920212223// 从二分搜索树中删除最大值所在节点, 返回最大值public func removeMax() -&gt;E?{ let ret = maxmum(); root = removeMax(node: root); return ret;}// 删除掉以node为根的二分搜索树中的最大节点// 返回删除节点后新的二分搜索树的根private func removeMax(node:Node&lt;E&gt;?)-&gt;Node&lt;E&gt;?{ if node == nil { return nil } if(node!.right == nil){ let leftNode = node?.left; node!.left = nil; size -= 1; return leftNode; } node!.right = removeMax(node: node!.right); return node;} 123456789101112131415161718192021222324252627var bst = BST&lt;Int&gt;()//var list = [1,4,6,2,3,4,55,67,8,9,10]var list = [11,21,23,20,5,6,7,8,9,3,11,12,4,14,15,16,17,18,19]for i in list { bst .add(e: i)}print(\"-------mini-----------\")print(bst.minimum() ?? -1)print(\"-------max-----------\")print(bst.maxmum() ?? -1)bst.removeMin()bst.removeMax()print(\"-------删除最小值后-----------\")print(bst.minimum() ?? -1)print(\"-------删除最大值-----------\")print(bst.maxmum() ?? -1)-------mini-----------3-------max-----------23-------删除最小值后-----------4-------删除最大值-----------21Program ended with exit code: 0 删除任意值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 从二分搜索树中删除元素为e的节点public func remove(e:E){ root = remove(node: root, e: e);}// 删除掉以node为根的二分搜索树中值为e的节点, 递归算法// 返回删除节点后新的二分搜索树的根private func remove(node:Node&lt;E&gt;?,e:E)-&gt;Node&lt;E&gt;?{ if( node == nil ){ return nil } if( e &lt; node!.e ){ node!.left = remove(node: node!.left , e: e) return node } else if(e &gt; node!.e){ node!.right = remove(node: node!.right, e: e) return node } else{ // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node!.left == nil){ let rightNode = node!.right node!.right = nil size -= 1 return rightNode } // 待删除节点右子树为空的情况 if(node!.right == nil){ let leftNode = node!.left node!.left = nil size -= 1 return leftNode } // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 let successor = Node(e: (minimum(node: node?.right)?.e)!) size += 1 successor.right = removeMin(node: node?.right) successor.left = node!.left node!.left = nil node!.right = nil size -= 1 return successor }}","link":"/2017/10/01/数据结构之二分搜索树2/"},{"title":"数据结构之字典LinkedMap实现","text":"字典12java里映射Map(HashMap、TreeMap(红黑树))oc、swift、python里的字典dict swift实现代码地址** 定义字典的接口1234567891011protocol MapAble { associatedtype K associatedtype V func add(key:K,Value:V) // 添加key、value func contains(key:K) -&gt;Bool // 检查是否存在key func remove(key:K) -&gt; V? // 移除key func getSize() -&gt;Int // 获取字典的大小 func isEmpty() -&gt; Bool // 判断字典是否为空 func get(key:K) -&gt; V? // 根据key获取value 不存在key返回nill func set(key:K,value:V) throws // 更新key对应的value 不存在key抛出异常} 实现基于链表的LinkedMap字典设计每个节点存放key，value的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/// 错误信息////// - msg: &lt;#msg description#&gt;enum UserError:Error { case msg(String)}/// 链表的节点class Node&lt;K,V&gt;:CustomDebugStringConvertible { var key:K? var value:V? var node:Node&lt;K,V&gt;? init(key:K?,value:V?, node:Node&lt;K,V&gt;?) { self.key = key self.value = value self.node = node } init() { self.key = nil self.value = nil self.node = nil } var debugDescription: String { var keyStr = \"nil\" if let key = self.key { keyStr = \"\\\"\\(key)\\\"\" } var vStr = \"nil\" if let v = self.value { vStr = \"\\\"\\(v)\\\"\" } return keyStr+\":\"+vStr }}/// 每个节点存放key，value的链表class LinkedList&lt;K,V&gt;:CustomDebugStringConvertible where K:Comparable { private var dummyHead:Node&lt;K,V&gt; private var size:Int init(){ self.dummyHead = Node&lt;K,V&gt;() self.size = 0 } // 获取链表中的元素个数 public func getSize()-&gt;Int{ return size } // 返回链表是否为空 public func isEmpty()-&gt;Bool{ return size == 0 } /// 查找key对应的节点 /// /// - Parameter key: key description /// - Returns: return value description private func getNode(key:K) -&gt; Node&lt;K, V&gt;? { var cur:Node&lt;K,V&gt;? = self.dummyHead.node while cur != nil { if let curKey = cur?.key { if curKey == key { return cur } } cur = cur?.node } return nil } /// 添加键值对 /// /// - Parameters: /// - key: key description /// - value: value description func add(key:K,value:V) { let node = getNode(key: key) if node == nil { self.dummyHead.node = Node&lt;K,V&gt;.init(key: key, value: value, node: self.dummyHead.node) self.size += 1 } else { node?.value = value } } /// 查询key是否存在 /// /// - Parameter key: key description /// - Returns: return value description func contains(key:K) -&gt; Bool { return (self.getNode(key: key) != nil) } /// 查询key对应的value /// /// - Parameter key: key description /// - Returns: return value description func get(key:K) -&gt; V? { return self.getNode(key: key)?.value } /// 设置简直对吗 /// /// - Parameters: /// - key: key description /// - value: value description /// - Throws: 当key不存在时抛出异常 func set(key:K,value:V) throws{ let node = self.getNode(key: key) if node==nil { throw UserError.msg(\"key不存在\") } node?.value = value } /// 移除key对应的节点 /// /// - Parameter key: key description /// - Returns: return value description func remove(key:K) -&gt; V? { var prev:Node&lt;K,V&gt;? = self.dummyHead; while(prev?.node != nil){ if let nodeKey = prev?.node?.key { if (nodeKey == key) { break; } } prev = prev?.node } if(prev?.node != nil){ let delNode = prev?.node prev?.node = delNode?.node delNode?.node = nil size -= 1 return delNode?.value } return nil } var debugDescription: String { var str = \"{\\n\" var node:Node&lt;K,V&gt;? = self.dummyHead for _ in 0..&lt;self.getSize() { node = node?.node if let nodeNoNull = node { str.append(\"\\t\\(String(describing: nodeNoNull))\" + \",\\n\") } } return str+\"}\" }} 根据带有key，value的节点的链表实现字典1234567891011121314151617181920212223242526272829303132333435363738394041class LinkedMap&lt;K,V&gt;:MapAble,CustomDebugStringConvertible where K:Comparable { var data: LinkedList&lt;K,V&gt; init() { self.data = LinkedList&lt;K,V&gt;() } func add(key: K, Value: V) { self.data.add(key: key, value: Value) } func contains(key: K) -&gt; Bool { return self.data.contains(key: key) } func remove(key: K) -&gt; V? { return self.data.remove(key: key) } func get(key: K) -&gt; V? { return self.data.get(key: key) } func set(key: K, value: V) throws { try self.data.set(key: key, value: value) } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } var debugDescription: String { return self.data.debugDescription } } LinkedMap的使用123456789let map = LinkedMap&lt;String,String&gt;()for i in 0...9 { map.add(key: \"key\\(i)\", Value: \"value\\(i)\")}print(\"添加后的字典-------\\n\"+map.debugDescription)try map.set(key: \"key5\", value: \"T##String\")print(\"变更key5的字典-------\\n\"+map.debugDescription)_ = map.remove(key: \"key8\")print(\"删除key8后的字典-------\\n\"+map.debugDescription) 打印结果123456789101112131415161718192021222324252627282930313233343536373839添加后的字典------- { \"key9\":\"value9\", \"key8\":\"value8\", \"key7\":\"value7\", \"key6\":\"value6\", \"key5\":\"value5\", \"key4\":\"value4\", \"key3\":\"value3\", \"key2\":\"value2\", \"key1\":\"value1\", \"key0\":\"value0\", } 变更key5的字典------- { \"key9\":\"value9\", \"key8\":\"value8\", \"key7\":\"value7\", \"key6\":\"value6\", \"key5\":\"T##String\", \"key4\":\"value4\", \"key3\":\"value3\", \"key2\":\"value2\", \"key1\":\"value1\", \"key0\":\"value0\", } 删除key8后的字典------- { \"key9\":\"value9\", \"key7\":\"value7\", \"key6\":\"value6\", \"key5\":\"T##String\", \"key4\":\"value4\", \"key3\":\"value3\", \"key2\":\"value2\", \"key1\":\"value1\", \"key0\":\"value0\", } Program ended with exit code: **0**","link":"/2017/10/03/数据结构之字典Map实现/"},{"title":"数据结构之栈实现","text":"栈swift代码 定义：栈是限定仅在表头进行插入和删除操作的线性表栈的功能协议接口1234567891011121314151617181920212223242526272829protocol StackAble { associatedtype E /// 查询栈的个数 /// /// - Returns: func func getSize() -&gt; Int /// 查询栈是否为空 /// /// - Returns: true false func isEmpty() -&gt; Bool /// 入栈 /// /// - Parameter e: 入栈的数据 /// - Returns: return value description mutating func push(e:E) throws /// 出栈 /// /// - Returns: 值 mutating func pop() throws -&gt; E? /// 查看栈顶的数据 /// /// - Returns: return value description func peek() throws -&gt; E?} 数组栈用数组实现栈结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct ArrayStack&lt;E&gt;: StackAble { private var data:[E] init() { self.data = Array&lt;E&gt;() } func getSize() -&gt; Int { return self.data.count } func isEmpty() -&gt; Bool { return self.data.count == 0 } mutating func push(e: E) throws{ self.data.insert(e, at: 0) } mutating func pop() throws -&gt; E? { let e = self.data.first if e == nil { throw OperationError.ErrorMsg(\"不存在\") } self.data.remove(at: 0) return e! } func peek() throws -&gt; E? { let e = self.data.first if e == nil { throw OperationError.ErrorMsg(\"栈顶不存在元素\") } return e! } // 重写基类中description属性 var description: String { var res = String(); res.append(\"Stack: \"); res.append(\"top [\"); for i in 0..&lt;self.data.count { res.append(\"\\(self.data[i])\"); if (i != self.data.count - 1){ res.append(\", \"); } } res.append(\"]\"); return res; }}/// 定义错误类型////// - ErrorMsg: ErrorMsg description/// - ErrorOther: ErrorOther descriptionenum OperationError : Error { case ErrorMsg(String) case ErrorOther} 数组栈的使用123456789var stack = ArrayStack&lt;Int&gt;()for i in 0...10 { stack.push(e: i) print(stack.description)}try! stack.pop()print(stack.description) 输出结果12345678910111213Stack: top [0]Stack: top [1, 0]Stack: top [2, 1, 0]Stack: top [3, 2, 1, 0]Stack: top [4, 3, 2, 1, 0]Stack: top [5, 4, 3, 2, 1, 0]Stack: top [6, 5, 4, 3, 2, 1, 0]Stack: top [7, 6, 5, 4, 3, 2, 1, 0]Stack: top [8, 7, 6, 5, 4, 3, 2, 1, 0]Stack: top [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]Stack: top [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]Stack: top [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]Program ended with exit code: 0 链表栈用链表实现栈结构链表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445struct LinkedStack&lt;E&gt;:StackAble where E:Equatable { var data: LinkedList&lt;E&gt; init() { self.data = LinkedList&lt;E&gt;() } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } mutating func push(e: E) throws { try self.data.addLast(e: e) } mutating func pop() throws -&gt; E? { return try self.data.removeFirst() } func peek() throws -&gt; E? { return try self.data.getFirst() } // 重写基类中description属性 var description: String { var res = String(); res.append(\"Stack: \"); res.append(\"top [\"); for i in 0..&lt;self.data.getSize() { if let e = (try? self.data.get(index: i)) { res.append(\"\\(String(describing:e ))\"); if (i != self.data.getSize() - 1){ res.append(\", \"); } } } res.append(\"]\"); return res; }} 链表栈的使用123456789var stack = LinkedStack&lt;Int&gt;()for i in 0...10 { try stack.push(e: i) print(stack.description)}try! stack.pop()print(stack.description) 输出结果12345678910111213链表栈: 栈顶 [0]链表栈: 栈顶 [0, 1]链表栈: 栈顶 [0, 1, 2]链表栈: 栈顶 [0, 1, 2, 3]链表栈: 栈顶 [0, 1, 2, 3, 4]链表栈: 栈顶 [0, 1, 2, 3, 4, 5]链表栈: 栈顶 [0, 1, 2, 3, 4, 5, 6]链表栈: 栈顶 [0, 1, 2, 3, 4, 5, 6, 7]链表栈: 栈顶 [0, 1, 2, 3, 4, 5, 6, 7, 8]链表栈: 栈顶 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]链表栈: 栈顶 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]链表栈: 栈顶 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]Program ended with exit code: 0","link":"/2017/09/14/数据结构之栈实现/"},{"title":"数据结构之链表实现","text":"链表swift代码 线性表的链式存储表示的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）链表的结构1234567891011121314151617181920212223public class Node&lt;Element&gt;: CustomDebugStringConvertible { public var e: Element? //数据域 public var node: Node&lt;Element&gt;? //指针域 init(e:Element?,node:Node&lt;Element&gt;?) { self.e = e self.node = node } convenience init(e:Element?) { self.init(e: e,node: nil) } convenience init() { self.init(e: nil,node: nil) } public var debugDescription: String { return self.e == nil ? \"nil\" : String(describing: self.e!) }} 链表的实现12345678910111213141516171819202122232425262728293031/// E 必须遵守相等协议 Equatableclass LinkedList&lt;E&gt; where E:Equatable { /// 虚拟头结点 private var dummyHead:Node&lt;E&gt; /// 链表的大小 private var size:Int init() { self.size = 0 self.dummyHead = Node&lt;E&gt;() } // 获取链表中的元素个数 public func getSize() -&gt; Int{ return size; } // 返回链表是否为空 public func isEmpty() -&gt; Bool{ return size == 0; } var description: String { var res = String(); var cur = dummyHead.node while(cur != nil){ res.append(cur!.debugDescription + \"-&gt;\"); cur = cur?.node } res.append(\"nil\") return res }} 链表的增123456789101112131415161718192021222324252627// 在链表的index(0-based)位置添加新的元素epublic func add(index:Int, e:E) throws -&gt; Void{ if (index &lt; 0 || index &gt; size){ throw OperationError.ErrorMsg(\"添加失败。非法索引。\") } var prev:Node&lt;E&gt;? = dummyHead; for _ in 0..&lt;index { prev = prev?.node } if let prev = prev { prev.node = Node.init(e: e, node: prev.node); } self.size += 1;}// 在链表头添加新的元素epublic func addFirst(e:E) throws -&gt; Void{ try add(index: 0, e: e);}// 在链表末尾添加新的元素epublic func addLast(e:E) throws -&gt; Void{ try add(index: size, e: e);} 链表的改123456789101112// 修改链表的第index(0-based)个位置的元素为epublic func set(index:Int, e:E) throws { if (index &lt; 0 || index &gt; size){ throw OperationError.ErrorMsg(\"添加失败。非法索引。\") } var cur = dummyHead.node for _ in 0..&lt;index { cur = cur?.node cur?.e = e }} 链表的查1234567891011121314151617181920212223242526272829303132333435363738// 获得链表的第index(0-based)个位置的元素public func get(index:Int) throws -&gt; E?{ if (index &lt; 0 || index &gt; size){ throw OperationError.ErrorMsg(\"添加失败。非法索引。\") } var cur = self.dummyHead.node; for _ in 0..&lt;index { cur = cur?.node } return cur?.e;}// 获得链表的第一个元素public func getFirst() throws -&gt; E?{ return try get(index: 0);}// 获得链表的最后一个元素public func getLast() throws -&gt; E?{ return try get(index: size - 1);}// 查找链表中是否有元素epublic func contains(e:E) -&gt; Bool{ var cur = dummyHead.node; while(cur != nil){ if let next = cur?.e { if next == e { return true } } cur = cur?.node } return false;} 链表的删123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 从链表中删除index(0-based)位置的元素, 返回删除的元素public func remove(index:Int) throws -&gt; E?{ if (index &lt; 0 || index &gt; size){ throw OperationError.ErrorMsg(\"添加失败。非法索引。\") } var prev:Node&lt;E&gt;? = dummyHead; for _ in 0..&lt;index { prev = prev?.node } let retNode = prev?.node prev?.node = retNode?.node retNode?.node = nil self.size -= 1 return retNode?.e;}// 从链表中删除第一个元素, 返回删除的元素public func removeFirst() throws -&gt; E?{ return try remove(index: 0);}// 从链表中删除最后一个元素, 返回删除的元素public func removeLast() throws -&gt; E?{ return try remove(index: size - 1);}// 从链表中删除元素epublic func removeElement(e:E){ var prev:Node&lt;E&gt;? = dummyHead while(prev?.node != nil){ if let next = prev?.e { if next == e { break; } } prev = prev?.node; } if(prev?.node != nil){ let delNode = prev?.node prev?.node = delNode?.node delNode?.node = nil }} 链表的使用12345678910111213141516171819202122232425var listed = LinkedList&lt;Int&gt;()print(\"增\")try listed.addLast(e: 0)try listed.addFirst(e: 10)try listed.add(index: 1, e: 12)try listed.addLast(e: 1)try listed.addFirst(e: 2)try listed.add(index: 4, e: 5)print(listed.description)print(\"查\")let first = try listed.getFirst()let last = try listed.getLast()let index = try listed.get(index: 2)print(\"查询first=====\\(first ?? 0)\\n查询last=====\\(last ?? 0)\\n查询index2=====:\\(index ?? 0)\")print(\"查询是否存在数字5===\\(listed.contains(e: 5))\")print(\"删\")try listed.removeLast()print(listed.description)try listed.removeFirst()print(listed.description)try listed.remove(index: 2)print(listed.description)print(\"改\")try listed.set(index: 1, e: 100)print(listed.description) 1234567891011121314增2-&gt;10-&gt;12-&gt;0-&gt;5-&gt;1-&gt;nil查查询first=====2查询last=====1查询index2=====:12查询是否存在数字5===true删2-&gt;10-&gt;12-&gt;0-&gt;5-&gt;nil10-&gt;12-&gt;0-&gt;5-&gt;nil10-&gt;12-&gt;5-&gt;nil改10-&gt;100-&gt;5-&gt;nilProgram ended with exit code: 0","link":"/2017/09/16/数据结构之链表实现/"},{"title":"数据结构之字典TreeMap实现","text":"swift实现代码地址 实现基于二分搜索树的TreeMap字典实现每个节点存放key，value的二叉搜索树1234567891011121314151617181920212223242526272829/// 二分上搜索树的节点class BstNode&lt;K,V&gt; :CustomDebugStringConvertible{ var key:K? var value:V? var left:BstNode&lt;K,V&gt;? var right:BstNode&lt;K,V&gt;? init() { self.right = nil self.left = nil self.key = nil self.value = nil } init(key:K,value:V) { self.key = key self.value = value } var debugDescription: String { var keyStr = \"nil\" if let key = self.key { keyStr = \"\\\"\\(key)\\\"\" } var vStr = \"nil\" if let v = self.value { vStr = \"\\\"\\(v)\\\"\" } return keyStr+\":\"+vStr }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/// 二分搜索树class BST&lt;K,V&gt; where K:Comparable { private var root: BstNode&lt;K,V&gt;? private var size: Int init() { self.root = nil self.size = 0 } func getSize() -&gt; Int { return self.size } func isEmpty() -&gt; Bool { return self.size == 0 } //MARK:添加元素 /// 添加元素 /// /// - Parameter e: e description func add(key:K,value:V) { self.root = self.add(node: self.root, key: key,value: value) } // 向以node为根的二分搜索树中插入元素e，递归算法 // 返回插入新节点后二分搜索树的根 private func add(node:BstNode&lt;K,V&gt;?, key:K,value:V)-&gt;BstNode&lt;K,V&gt;{ guard let node = node else { self.size+=1 return BstNode.init(key: key, value: value) } if key &lt; node.key! { node.left = add(node: node.left,key: key, value: value) } else if key &gt; node.key! { node.right = add(node: node.right, key: key, value: value) } return node } /// 获取key对应的value /// /// - Parameter key: &lt;#key description#&gt; /// - Returns: &lt;#return value description#&gt; func get(key:K) -&gt; V? { return self.get(key: key, node: self.root)?.value } func set(key:K,value:V) throws { let node = self.get(key: key, node: self.root) if node==nil { throw UserError.msg(\"key不存在\") } node?.value = value } private func get(key:K,node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } if key &lt; node.key! { return self.get(key: key, node: node.left) } else if key &gt; node.key! { return self.get(key: key, node: node.right) } return node } // MARK:查看是否存在元素e /// 查看是否存在元素e /// /// - Parameter e: 查询的元素 /// - Returns: true表示存在，否则表示不存在 func contains(key:K) -&gt; Bool { return self.contains(key: key, node: self.root) } private func contains(key:K,node:BstNode&lt;K,V&gt;?) -&gt; Bool { guard let node = node else { return false } if key &lt; node.key! { return self.contains(key: key, node: node.left) } else if key &gt; node.key! { return self.contains(key: key, node: node.right) } return true } //MARK:前序遍历 /// 前序遍历 func preOrder() { self.preOrder(node: self.root) } private func preOrder(node:BstNode&lt;K,V&gt;?) { guard let node = node else { return } print(node) preOrder(node: node.left) preOrder(node: node.right) } //MARK:中序遍历 /// 中序遍历 func inOrder() { self.inOrder(node: self.root) } private func inOrder(node:BstNode&lt;K,V&gt;?) { guard let node = node else { return } preOrder(node: node.left) print(node) preOrder(node: node.right) } //MARK:后序遍历 /// 后序遍历 func postOrder() { self.postOrder(node: self.root) } private func postOrder(node:BstNode&lt;K,V&gt;?) { guard let node = node else { return } postOrder(node: node.left) postOrder(node: node.right) print(node) } //MARK:层序遍历 /// 层序遍历 func levelOrder() { let q = Queue&lt;BstNode&lt;K,V&gt;&gt;() guard let root = self.root else { return } q.push(e: root) while !q.isEmpty() { let cur = q.pop() if let cur = cur { print(cur) if cur.left != nil{ q.push(e: cur.left!) }else if cur.right != nil{ q.push(e: cur.right!) } } } } //MARK:前序非递归遍历 /// 前序非递归遍历 func preOrderRN() { let stack = Stack&lt;BstNode&lt;K,V&gt;&gt;() guard let root = self.root else { return } stack.push(e: root) while !stack.isEmpty() { let cur = stack.pop() if let cur = cur { print(cur) if cur.left != nil{ stack.push(e: cur.left!) }else if cur.right != nil{ stack.push(e: cur.right!) } } } } //MARK: 寻找最小元素 /// 寻找最小元素 /// /// - Returns: return value description func minimum() -&gt; K? { if self.size==0 { return nil } return self.minimum(node: self.root)?.key } private func minimum(node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } if node.left != nil { return self.minimum(node: node.left) } return node } //MARK: 寻找最大元素 /// 寻找最大元素 /// /// - Returns: return value description func maxmum() -&gt; K? { if self.size==0 { return nil } return self.maxmum(node: self.root)?.key } private func maxmum(node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } if node.right == nil { return node } return self.maxmum(node: node.right) } //MARK:删除最小值 /// 删除x最小值 /// /// - Returns: return value description func removeMin() -&gt; K? { let data = self.minimum() self.root = removeMin(node: self.root) return data } private func removeMin(node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } if node.left == nil { let rightNode = node.right node.right = nil size -= 1 return rightNode } node.left = self.removeMin(node: node.left) return node } //MARK:移除最大值 /// 移除最大值 /// /// - Returns: return value description func removeMax() -&gt; K? { let data = self.maxmum() self.root = self.removeMin(node: self.root) return data } private func removeMax(node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } if node.right == nil { let leftnode = node.left node.left = nil self.size -= 1 return leftnode } node.right = removeMax(node: node.right) return node } //MARK:移除任意值 /// 移除任意值 /// /// - Returns: return value description func remove(key:K) { self.root = remove(key: key, node: self.root) } private func remove(key:K,node:BstNode&lt;K,V&gt;?) -&gt; BstNode&lt;K,V&gt;? { guard let node = node else { return nil } guard let eval = node.key else { return nil } if key &lt; eval { node.left = remove(key: key, node: node.left) return node } else if key &gt; eval { node.right = remove(key: key, node: node.right) return node } else { // 待删除节点左子树为空的情况 if node.left == nil { let rightNode = node.right node.right = nil self.size -= 1 return rightNode } // 待删除节点右子树为空的情况 if node.right == nil { let leftNode = node.left node.left = nil self.size -= 1 return leftNode } let successor = self.minimum(node: node.right) successor?.right = self.removeMin(node: node.right) successor?.left = node.left node.left = nil node.right = nil return successor } } } 根据二叉搜索树实现TreeMap1234567891011121314151617181920212223242526272829303132333435363738394041424344class BSTMap&lt;K,V&gt;:MapAble,CustomDebugStringConvertible where K:Comparable { var data: BST&lt;K,V&gt; init() { self.data = BST&lt;K,V&gt;() } func add(key: K, Value: V) { self.data.add(key: key, value: Value) } func contains(key: K) -&gt; Bool { return self.data.contains(key: key) } func remove(key: K) -&gt; V? { let data = self.data.get(key: key) self.data.remove(key: key) return data } func get(key: K) -&gt; V? { return self.data.get(key: key) } func set(key: K, value: V) throws { try self.data.set(key: key, value: value) } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } var debugDescription: String { self.data.inOrder() return \"\" } } LinkedMap的使用let map1 = BSTMap&lt;String,String&gt;() for i in 0…9 { map1.add(key: “key(i)”, Value: “value(i)”)}print(“添加后的字典——-\\n”)map1.debugDescriptiontry map1.set(key: “key5”, value: “T##String”)print(“变更key5的字典——-\\n”)map1.debugDescription_ = map1.remove(key: “key8”)print(“删除key8后的字典——-\\n”)map1.debugDescription1234567891011121314151617181920212223242526272829303132333435#### 打印结果 ```swift添加后的字典-------&quot;key0&quot;:&quot;value0&quot;&quot;key1&quot;:&quot;value1&quot;&quot;key2&quot;:&quot;value2&quot;&quot;key3&quot;:&quot;value3&quot;&quot;key4&quot;:&quot;value4&quot;&quot;key5&quot;:&quot;value5&quot;&quot;key6&quot;:&quot;value6&quot;&quot;key7&quot;:&quot;value7&quot;&quot;key8&quot;:&quot;value8&quot;&quot;key9&quot;:&quot;value9&quot;变更key5的字典-------&quot;key0&quot;:&quot;value0&quot;&quot;key1&quot;:&quot;value1&quot;&quot;key2&quot;:&quot;value2&quot;&quot;key3&quot;:&quot;value3&quot;&quot;key4&quot;:&quot;value4&quot;&quot;key5&quot;:&quot;T##String&quot;&quot;key6&quot;:&quot;value6&quot;&quot;key7&quot;:&quot;value7&quot;&quot;key8&quot;:&quot;value8&quot;&quot;key9&quot;:&quot;value9&quot;删除key8后的字典-------&quot;key0&quot;:&quot;value0&quot;&quot;key1&quot;:&quot;value1&quot;&quot;key2&quot;:&quot;value2&quot;&quot;key3&quot;:&quot;value3&quot;&quot;key4&quot;:&quot;value4&quot;&quot;key5&quot;:&quot;T##String&quot;&quot;key6&quot;:&quot;value6&quot;&quot;key7&quot;:&quot;value7&quot;&quot;key9&quot;:&quot;value9&quot;Program ended with exit code: 0","link":"/2017/10/03/数据结构之字典TreeMap实现/"},{"title":"数据结构之队列实现","text":"队列swift代码 定义：它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表队列的功能协议接口123456789101112131415161718192021222324252627282930protocol QueueAble { associatedtype E /// 查询队列的个数 /// /// - Returns: func func getSize() -&gt; Int /// 查询队列是否为空 /// /// - Returns: true false func isEmpty() -&gt; Bool /// 入队列 /// /// - Parameter e: 入队列的数据 /// - Returns: return value description mutating func enqueue(e:E) throws /// 出队列 /// /// - Returns: 值 mutating func dequeue() throws -&gt; E? /// 查看队列顶的数据 /// /// - Returns: return value description func getFront() throws -&gt; E?} 数组队列用数组实现队列结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct ArrayQueue&lt;E&gt;: QueueAble { private var data:[E] init() { self.data = Array&lt;E&gt;() } func getSize() -&gt; Int { return self.data.count } func isEmpty() -&gt; Bool { return self.data.count == 0 } mutating func enqueue(e: E) throws{ self.data.append(e) } mutating func dequeue() throws -&gt; E? { let e = self.data.first if e == nil { throw OperationError.ErrorMsg(\"不存在\") } self.data.remove(at: 0) return e! } func getFront() throws -&gt; E? { let e = self.data.first if e == nil { throw OperationError.ErrorMsg(\"栈顶不存在元素\") } return e! } // 重写基类中description属性 var description: String { var res = String(); res.append(\"队列: \"); res.append(\"队首 [\"); for i in 0..&lt;self.data.count { res.append(\"\\(self.data[i])\"); if (i != self.data.count - 1){ res.append(\", \"); } } res.append(\"] 队尾\"); return res; }} 数组队列的使用12345678910111213141516var queue = ArrayQueue&lt;Int&gt;()print(\"开始加入队列\")for i in 0...10 { queue.enqueue(e: i) print(queue.description)}print(\"加入完成\")print(\"-------------\")print(\"第一次出队\")try! queue.dequeue()print(queue.description)print(\"第二次出队\")try! queue.dequeue()print(queue.description)print(\"出队完成\") 输出结果12345678910111213141516171819开始加入队列队列: 队首 [0] 队尾队列: 队首 [0, 1] 队尾队列: 队首 [0, 1, 2] 队尾队列: 队首 [0, 1, 2, 3] 队尾队列: 队首 [0, 1, 2, 3, 4] 队尾队列: 队首 [0, 1, 2, 3, 4, 5] 队尾队列: 队首 [0, 1, 2, 3, 4, 5, 6] 队尾队列: 队首 [0, 1, 2, 3, 4, 5, 6, 7] 队尾队列: 队首 [0, 1, 2, 3, 4, 5, 6, 7, 8] 队尾队列: 队首 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 队尾队列: 队首 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 队尾加入完成-------------第一次出队队列: 队首 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 队尾第二次出队队列: 队首 [2, 3, 4, 5, 6, 7, 8, 9, 10] 队尾出队完成 循环队列用数组循环实现队列结构链表队列用链表实现队列结构链表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445struct LinkedStack&lt;E&gt;:StackAble where E:Equatable { var data: LinkedList&lt;E&gt; init() { self.data = LinkedList&lt;E&gt;() } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } mutating func push(e: E) throws { try self.data.addLast(e: e) } mutating func pop() throws -&gt; E? { return try self.data.removeFirst() } func peek() throws -&gt; E? { return try self.data.getFirst() } // 重写基类中description属性 var description: String { var res = String(); res.append(\"链表栈: \"); res.append(\"栈顶 [\"); for i in 0..&lt;self.data.getSize() { if let e = (try? self.data.get(index: i)) { res.append(\"\\(String(describing:e ))\"); if (i != self.data.getSize() - 1){ res.append(\", \"); } } } res.append(\"]\"); return res; }} 链表栈的使用123456789101112131415var queue = LinkedQueue&lt;Int&gt;()print(\"开始加入队列\")for i in 0...10 { try queue.enqueue(e: i) print(queue.description)}print(\"加入完成\")print(\"-------------\")print(\"第一次出队\")try! queue.dequeue()print(queue.description)print(\"第二次出队\")try! queue.dequeue()print(queue.description)print(\"出队完成\") 输出结果1234567891011121314151617181920开始加入队列链表队列: 队首 [0] 队尾链表队列: 队首 [1, 0] 队尾链表队列: 队首 [2, 1, 0] 队尾链表队列: 队首 [3, 2, 1, 0] 队尾链表队列: 队首 [4, 3, 2, 1, 0] 队尾链表队列: 队首 [5, 4, 3, 2, 1, 0] 队尾链表队列: 队首 [6, 5, 4, 3, 2, 1, 0] 队尾链表队列: 队首 [7, 6, 5, 4, 3, 2, 1, 0] 队尾链表队列: 队首 [8, 7, 6, 5, 4, 3, 2, 1, 0] 队尾链表队列: 队首 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 队尾链表队列: 队首 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 队尾加入完成-------------第一次出队链表队列: 队首 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] 队尾第二次出队链表队列: 队首 [10, 9, 8, 7, 6, 5, 4, 3, 2] 队尾出队完成Program ended with exit code: 0 分析链表队列121、加入队列 O(1)2、移除队列 O(n) 链表队列优化从尾节点入队列，从首节点出队列1234567891011121314class LinkedList2&lt;E&gt;: LinkedList&lt;E&gt; where E:Equatable { /// 尾结点 private var foot:Node&lt;E&gt;? override init() { super.init() self.foot = self.dummyHead } override func addLast(e: E) throws { self.foot?.node = Node.init(e: e, node: nil) self.foot = self.foot?.node self.size += 1; }} 123456789101112131415161718192021222324252627282930313233343536373839404142struct LinkedQueue2&lt;E&gt;: QueueAble where E:Equatable { private var data:LinkedList2&lt;E&gt; init() { self.data = LinkedList2&lt;E&gt;() } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.getSize() == 0 } mutating func enqueue(e: E) throws{ try self.data.addLast(e: e) } mutating func dequeue() throws -&gt; E? { return try self.data.removeFirst() } func getFront() throws -&gt; E? { return try self.data.getFirst() } // 重写基类中description属性 var description: String { var res = String(); res.append(\"链表队列: \"); res.append(\"队首 [\"); for i in 0..&lt;self.data.getSize() { if let e = try? self.data.get(index: i) { res.append(\"\\(e)\"); if (i != self.data.getSize() - 1){ res.append(\", \"); } } } res.append(\"] 队尾\"); return res; }}","link":"/2017/09/14/数据结构之队列实现/"},{"title":"数据结构之集合实现","text":"集合swift实现代码 集合（Set）是用来存储相同类型、没有确定顺序、且不重复的值。 也就是说当元素顺序不重要时，或者希望确保每个元素只出现一次时，可以使用集合而不是数组。 链表实现集合1234567891011121314151617181920212223242526272829303132class LinkedListSet&lt;E&gt;: SetAble,CustomDebugStringConvertible where E:Equatable{ private var data: LinkedList&lt;E&gt; init() { self.data = LinkedList&lt;E&gt;() } func add(e: E) { if !self.data.contains(e: e) { self.data.addFirst(e: e) } } func contains(e: E) -&gt; Bool { return self.data.contains(e: e) } func remove(e: E) { self.data.removeElement(e: e) } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } var debugDescription: String { return self.data.debugDescription }} 由上图可看出 链表实现的集合添加元素的时间复杂度为O(n) 搜索树实现集合二分搜索树实现集合12345678910111213141516171819202122232425262728293031class BSTSet&lt;E&gt;:SetAble where E:Comparable { private var data: BST&lt;E&gt; init() { self.data = BST&lt;E&gt;() } func add(e: E) { self.data.add(e: e) } func contains(e: E) -&gt; Bool { return self.data.contains(e: e) } func remove(e: E) { self.data.remove(e: e) } func getSize() -&gt; Int { return self.data.getSize() } func isEmpty() -&gt; Bool { return self.data.isEmpty() } var debugDescription: String { self.data.preOrderRN() return \"\" }} 由上图可看出 二分搜索树实现的集合增删查元素的时间复杂度为O(**logn**)","link":"/2017/10/01/数据结构之集合实现/"},{"title":"算法-：排序算法","text":"比较排序 定义1 (基于比较的排序)给定一个包含n个对象的待排序序列a1a2…an. 假设我们知道如何比较其中任意两个对象的大小关系。只如何对这一序列排序 121. 传递性：如果a&lt;=b ,b&lt;=c,则一定有a&lt;=c2. 全序性：对任意a和b，或者a&lt;=b，或者b&lt;=c 定义2 (合并多个有序列)将n个序列合并为一个序列。 定义3(前k小数)给定一个包含n个对象的序列 找出前k个最小的数 1. 梳排序12345678冒泡排序for i＝0,2,…,n-1 do for j＝1,2,…,n-i do if aj＞aj+1 then 交换aj和aj+1 endif endifendif 12345678910111213public void bubbleSort(int[] a) { boolean exchange; for(int i = a.length - 1; i &gt; 0; i--) { exchange = false; for(int j = 0; j &lt; i; j++) { if(a[j] &gt; a[j+1]) { swap(a, j, j+1); exchange = true; } } if(!exchange) return; }} 123456789101112梳排序j←n,s←1.3,flag←falseWhile j＞1或者flag＝true do i←0，j←max{|j/s|，1}，flag＝false while i+j ≦ n do If ai ＞ ai＋j then 交换ai和ai＋j flag←true endif i←i＋1 end whileend while 2. 堆排序12 3. 归并排序4. 快速排序5. 内省培训6. Timsort非比较排序1. 桶排序2. 基数培训","link":"/2018/03/12/算法-：排序算法/"},{"title":"编译系统LLVM","text":"关于LVVMLLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。创始人:Chris Lattner，亦是Swift之父 传统编译架构 Frontend:前端词法分析、语法分析、语义分析、生成中间代码 Optimizer:优化器中间代码优化 Backend:后端生成机器码 LLVM架构 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR) 如果需要支持一种新的编程语言，那么只需要实现一个新的前端 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改 相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就 变得特别困难 LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)什么是Clang LLVM项目的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端。 相比于GCC，Clang具有如下优点 编译速度快:在某些平台上，Clang的编译速度显著的快过GCC(Debug模式下编译OC速度比GGC快3倍) 占用内存小:Clang生成的AST所占用的内存是GCC的五分之一左右 模块化设计:Clang采用基于库的模块化设计，易于 IDE 集成及其他用途的重用 诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告 设计清晰简单，容易理解，易于扩展增强 Clang与LLVM关系 LLVM整体架构，前端用的是clang，广义的LLVM是指整个LLVM架构，一般狭义的LLVM指的是LLVM后端（包含代码优化和目标代码生成）。源代码（c/c++）经过clang–&gt; 中间代码(经过一系列的优化，优化用的是Pass) –&gt; 机器码 OC源文件的编译过程这里用Xcode创建一个Test项目，然后cd到main.m的上一路径。命令行查看编译的过程:$ clang -ccc-print-phases main.m123456789$ clang -ccc-print-phases main.m 0: input, \"main.m\", objective-c1: preprocessor, {0}, objective-c-cpp-output2: compiler, {1}, ir3: backend, {2}, assembler4: assembler, {3}, object5: linker, {4}, image6: bind-arch, \"x86_64\", {5}, image 找到main.m文件 预处理器，处理include、import、宏定义 编译器编译，编译成ir中间代码 后端，生成目标代码 汇编 链接其他动态库静态库 编译成适合某个架构的代码查看 preprocessor (预处理)的结果:$ clang -E main.m这个命令敲出，终端就会打印许多信息，大致如下： 12345678910111213141516# 1 \"main.m\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 353 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"main.m\" 2... int main(int argc, const char * argv[]) {@autoreleasepool { NSLog(@\"Hello, World!\");}return 0;} 词法分析词法分析，生成Token: $ clang -fmodules -E -Xclang -dump-tokens main.m将代码分成一个个小单元（token）举例如下：12345678910111213141516171819202122232425void test(int a, int b){ int c = a + b - 3; }void 'void' [StartOfLine] Loc=&lt;main.m:18:1&gt;identifier 'test' [LeadingSpace] Loc=&lt;main.m:18:6&gt;l_paren '(' Loc=&lt;main.m:18:10&gt;int 'int' Loc=&lt;main.m:18:11&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.m:18:15&gt;comma ',' Loc=&lt;main.m:18:16&gt;int 'int' [LeadingSpace] Loc=&lt;main.m:18:18&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.m:18:22&gt;r_paren ')' Loc=&lt;main.m:18:23&gt;l_brace '{' Loc=&lt;main.m:18:24&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:19:5&gt;identifier 'c' [LeadingSpace] Loc=&lt;main.m:19:9&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:19:11&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.m:19:13&gt;plus '+' [LeadingSpace] Loc=&lt;main.m:19:15&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.m:19:17&gt;minus '-' [LeadingSpace] Loc=&lt;main.m:19:19&gt;numeric_constant '3' [LeadingSpace] Loc=&lt;main.m:19:21&gt;semi ';' Loc=&lt;main.m:19:22&gt;r_brace '}' [StartOfLine] Loc=&lt;main.m:20:1&gt;eof '' Loc=&lt;main.m:20:2&gt; 可以看出，词法分析的时候，将上面的代码拆分一个个token，后面数字表示某一行的第几个字符，例如第一个void，表示第18行第一个字符。 语法树-AST语法分析，生成语法树(AST，Abstract Syntax Tree): $ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m通过语法树，我们能知道这个代码是做什么的。还是刚刚的test函数生成语法树如下：123456789101112131415|-FunctionDecl 0x7fa1439f5630 &lt;line:18:1, line:20:1&gt; line:18:6 test 'void (int, int)'| |-ParmVarDecl 0x7fa1439f54b0 &lt;col:11, col:15&gt; col:15 used a 'int'| |-ParmVarDecl 0x7fa1439f5528 &lt;col:18, col:22&gt; col:22 used b 'int'| `-CompoundStmt 0x7fa142167c88 &lt;col:24, line:20:1&gt;| `-DeclStmt 0x7fa142167c70 &lt;line:19:5, col:22&gt;| `-VarDecl 0x7fa1439f5708 &lt;col:5, col:21&gt; col:9 c 'int' cinit| `-BinaryOperator 0x7fa142167c48 &lt;col:13, col:21&gt; 'int' '-'| |-BinaryOperator 0x7fa142167c00 &lt;col:13, col:17&gt; 'int' '+'| | |-ImplicitCastExpr 0x7fa1439f57b8 &lt;col:13&gt; 'int' &lt;LValueToRValue&gt;| | | `-DeclRefExpr 0x7fa1439f5768 &lt;col:13&gt; 'int' lvalue ParmVar 0x7fa1439f54b0 'a' 'int'| | `-ImplicitCastExpr 0x7fa1439f57d0 &lt;col:17&gt; 'int' &lt;LValueToRValue&gt;| | `-DeclRefExpr 0x7fa1439f5790 &lt;col:17&gt; 'int' lvalue ParmVar 0x7fa1439f5528 'b' 'int'| `-IntegerLiteral 0x7fa142167c28 &lt;col:21&gt; 'int' 3`-&lt;undeserialized declarations&gt; 在终端敲出的时候，终端很直观的帮我们用颜色区分。我们可以用图形显示如下： LLVM IRLLVM IR有3种表示形式（本质是等价的） text:便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m memory:内存格式 bitcode:二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m 我们以text形式编译查看：1234567891011121314; Function Attrs: noinline nounwind optnone ssp uwtabledefine void @test(i32, i32) #2 { %3 = alloca i32, align 4 %4 = alloca i32, align 4 %5 = alloca i32, align 4 store i32 %0, i32* %3, align 4 store i32 %1, i32* %4, align 4 %6 = load i32, i32* %3, align 4 %7 = load i32, i32* %4, align 4 %8 = add nsw i32 %6, %7 %9 = sub nsw i32 %8, 3 store i32 %9, i32* %5, align 4 ret void} IR基本语法注释以分号 ; 开头 全局标识符以@开头，局部标识符以%开头 alloca，在当前函数栈帧中分配内存 i32，32bit，4个字节的意思 align，内存对齐 store，写入数据 load，读取数据 官方语法参考 https://llvm.org/docs/LangRef.html","link":"/2017/12/28/编译系统LLVM/"},{"title":"数据结构之二叉堆","text":"堆的性质 堆是一颗完全二叉树 堆的顶端一定是“最大”，最小”的，但是要注意一个点，这里的大和小并不是传统意义下的大和小，它是相对于优先级而言的，当然你也可以把优先级定为传统意义下的大小，但一定要牢记这一点，初学者容易把堆的“大小”直接定义为传统意义下的大小，某些题就不是按数字的大小为优先级来进行堆的操作的（但是为了讲解方便，下文直接把堆的优先级定为传统意义下的大小，所以上面跟没讲有什么区别？） 堆一般有两种样子，小根堆和大根堆，分别对应第二个性质中的“堆顶最大”“堆顶最小”，对于大根堆而言，任何一个非根节点，它的优先级都小于堆顶，对于小根堆而言，任何一个非根节点，它的优先级都大于堆顶（这里的根就是堆顶啦qwq） 来一张图了解一下堆（这里是大根堆）（原谅丑陋无比的图） 最大堆是一个完全二叉树，可用数组存放如下，满足以下条件不必须从索引1开始才可以 也可以从0开始 索引从1开始存放数据时 data 80 73 71 68 58 48 40 3 13 7 8 17 43 25 index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 12345678在下标为K的结点 它的左孩子为**2K**的下标结点 右孩子为**2K+1**结点 父亲为**K/2** (强制取整)比如 下标为2的值为73 左孩子为2*2=4的下标值为68 右孩子为2*2+1=5的下标值为58 父亲为2/2=1的下标值为80 不必须从索引1开始才可以 也可以从0开始 索引从0开始存放数据时 data 80 73 71 68 58 48 40 3 13 7 8 17 43 25 index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 12345678在下标为K的结点 它的左孩子为**2K+1**的下标结点 右孩子为**2K+2**结点 父亲为**(K-1)/2** (强制取整)比如 下标为3的值为68 左孩子为3*2+1=7的下标值为3 右孩子为3*2+2=8的下标值为13 父亲为(2-1)/2=1的下标值为73 用数组实现最大堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495enum UserError:Error { case msg(String)}extension Array { /// 替换数组的两个索引对应的值 /// /// - Parameters: /// - i: i description /// - j: j description /// - Returns: 返回true表示替换成功 f否则表示没有替换成功 public mutating func swap(i:Int,j:Int) -&gt;Bool { if i&lt;0 &amp;&amp; i&gt;=self.count { return false } if j&lt;0 &amp;&amp; j&gt;=self.count { return false } let temp = self[i] self[i] = self[j] self[j] = temp return true }}class MaxHeap&lt;E&gt;:CustomDebugStringConvertible where E:Comparable { var data:Array&lt;E&gt; init() { self.data = Array&lt;E&gt;() } ///回去节点个数 func size() -&gt; Int { return self.data.count } ///判断是否为空 func isEmpty() -&gt; Bool { return self.data.count == 0 } /// 计算index的父节点的值 /// /// - Parameter index: &lt;#index description#&gt; /// - Returns: return value description private func parent(index:Int) -&gt; Int { if index==0 { return 0 } return (index-1) / 2 } /// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 /// /// - Parameter index: index description /// - Returns: return value description private func leftChild(index:Int) -&gt; Int { return index * 2 + 1 } /// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 /// /// - Parameter index: index description /// - Returns: return value description private func rightChild(index:Int) -&gt; Int { return index * 2 + 1 } /// 添加节点 /// 每次添加数据时添加到数据尾部 /// 跟父节点比较大小 上浮节点 /// - Parameter e: e description func add(e:E) { self.data.append(e)//添加到数组中 siftUp(n: (self.size()-1)) } /// 上浮节点 /// /// - Parameter n: 节点的索引 private func siftUp(n: Int) { var k = n while k &gt; 0 &amp;&amp; self.data[self.parent(index: k)] &lt; self.data[k] { _ = self.data.swap(i: k, j: self.parent(index: k)) k = self.parent(index: k) } } var debugDescription: String { var str = \"[\" for item in self.data { str.append(\"\\(item),\") } str.append(\"]\") return str }} 使用12345678var data = MaxHeap&lt;Int&gt;()for i in 0...100 { if i % 3 == 0 { data.add(e: i) }}print(data) 打印结果1[99,96,87,93,60,72,84,90,45,51,57,39,69,75,81,48,63,9,42,6,24,21,54,3,30,15,66,12,36,33,78,0,27,18,] 扩展12345678910111213141516171819202122232425262728293031323334353637383940/// 查找堆得最大元素////// - Returns: 最大元素func findMax() -&gt; E? { if self.size()==0 { return nil } return self.data.first}/// 从堆里面移除最大值////// - Returns: 最大元素func extractMax() -&gt; E? { let data = self.findMax() _ = self.data.swap(i: 0, j: self.size()-1)//与s最后一位元素交换位置 self.data.remove(at: self.size()-1) //从数组移除最大值 self.siftDown(n: 0) //依次比较该元素与其左右孩子的大小 return data}/// 下浮节点////// - Parameter n: 节点的索引private func siftDown(n:Int) { var k = n while self.leftChild(index: k) &lt; self.size() { var leftC = self.leftChild(index: k) if leftC+1&lt;self.size() &amp;&amp; self.data[leftC+1] &gt; self.data[leftC] { leftC += 1 } if data[k] &gt; self.data[leftC] { break } _ = self.data.swap(i: k, j: leftC) k = leftC }} 使用12345print(data.extractMax() ?? 0)print(data.extractMax() ?? 0)print(data.extractMax() ?? 0)print(data.extractMax() ?? 0)print(data) 打印结果1234599969390[87,63,84,48,60,72,81,27,45,51,57,39,69,75,78,0,18,9,42,6,24,21,54,3,30,15,66,12,36,33,]","link":"/2018/07/22/数据结构之二叉堆/"},{"title":"玩转Linux","text":"基础命令Linux系统的命令通常都是如下所示的格式： 1命令名称 [命名参数] [命令对象] 获取登录信息 - w / who / last。 12345678910[root@guotz ~]# w23:31:16 up 12:16, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 182.139.66.250 23:03 4.00s 0.02s 0.00s wjackfrue pts/1 182.139.66.250 23:26 3:56 0.00s 0.00s -bash[root@guotz ~]# whoroot pts/0 2018-04-12 23:03 (182.139.66.250)jackfrued pts/1 2018-04-12 23:26 (182.139.66.250)[root@guotz ~]# who am iroot pts/0 2018-04-12 23:03 (182.139.66.250) 查看自己使用的Shell - ps。 Shell也被称为“壳”，它是用户与内核交流的翻译官，简单的说就是人与计算机交互的接口。目前很多Linux系统默认的Shell都是bash（Bourne Again SHell），因为它可以使用Tab键进行命令补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作等。 1234[root@guotz ~]# ps PID TTY TIME CMD3531 pts/0 00:00:00 bash3553 pts/0 00:00:00 ps 查看命令的说明 - whatis。 1234[root@guotz ~]# whatis psps (1) - report a snapshot of the current processes.[root@guotz ~]# whatis pythonpython (1) - an interpreted, interactive, object-oriented programming language 查看命令的位置 - which / whereis。 12345678[root@guotz ~]# whereis psps: /usr/bin/ps /usr/share/man/man1/ps.1.gz[root@guotz ~]# whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz[root@guotz ~]# which ps/usr/bin/ps[root@guotz ~]# which python/usr/bin/python 查看帮助文档 - man / info / apropos。 1234567891011121314151617[root@guotz ~]# ps --helpUsage:ps [options]Try 'ps --help &lt;simple|list|output|threads|misc|all&gt;' or 'ps --help &lt;s|l|o|t|m|a&gt;'for additional help text.For more details see ps(1).[root@guotz ~]# man psPS(1) User Commands PS(1)NAME ps - report a snapshot of the current processes.SYNOPSIS ps [options]DESCRIPTION...[root@guotz ~]# info ps... 切换用户 - su。 12[root@guotz ~]# su hellokitty[hellokitty@guotz root]$ 以管理员身份执行命令 - sudo。 12345[jackfrued@guotz ~]$ ls /rootls: cannot open directory /root: Permission denied[jackfrued@guotz ~]$ sudo ls /root[sudo] password for jackfrued:calendar.py code error.txt hehe hello.c index.html myconf result.txt 说明：如果希望用户能够以管理员身份执行命令，用户必须被添加到sudoers名单中，该文件在 /etc目录下。 登入登出相关 - logout / exit / adduser / userdel / passwd / ssh。 123456789101112[root@guotz ~]# adduser hellokitty[root@guotz ~]# passwd hellokittyChanging password for user jackfrued.New password:Retype new password:passwd: all authentication tokens updated successfully.[root@guotz ~]# ssh hellokitty@1.2.3.4hellokitty@1.2.3.4's password:Last login: Thu Apr 12 23:05:32 2018 from 10.12.14.16[hellokitty@guotz ~]$ logoutConnection to 1.2.3.4 closed.[root@guotz ~]# 查看系统和主机名 - uname / hostname。 123456[root@guotz ~]# unameLinux[root@guotz ~]# hostnameguotz[root@guotz ~]# cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core) 重启和关机 - reboot / init 6 / shutdown / init 0。 查看历史命令 - history。 1234567[root@guotz ~]# history...452 ls453 cd Python-3.6.5/454 clear455 history[root@guotz ~]# !454 说明：查看到历史命令之后，可以用!历史命令编号来重新执行该命令；通过history -c可以清除历史命令。 实用程序文件和文件夹操作 创建/删除目录 - mkdir / rmdir。 123[root@guotz ~]# mkdir abc[root@guotz ~]# mkdir -p xyz/abc[root@guotz ~]# rmdir abc 创建/删除文件 - touch / rm。 12345[root@guotz ~]# touch readme.txt[root@guotz ~]# touch error.txt[root@guotz ~]# rm error.txtrm: remove regular empty file ‘error.txt’? y[root@guotz ~]# rm -rf xyz touch命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间： 更改内容的时间 - mtime。 更改权限的时间 - ctime。 最后访问时间 - atime。 rm的几个重要参数： -i：交互式删除，每个删除项都会进行询问。 -r：删除目录并递归的删除目录中的文件和目录。 -f：强制删除，忽略不存在的文件，没有任何提示。 切换和查看当前工作目录 - cd / pwd。 说明：cd命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以/开头）来切换到指定的目录，也可以用cd ..来返回上一级目录。 查看目录内容 - ls。 -l：以长格式查看文件和目录。 -a：显示以点开头的文件和目录（隐藏文件）。 -R：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。 -d：只列出目录，不列出其他内容。 -S/-t：按大小/时间排序。 查看文件内容 - cat / head / tail / more / less。 12345678910111213141516171819202122232425262728[root@guotz ~]# wget http://www.sohu.com/ -O sohu.html--2018-06-20 18:42:34-- http://www.sohu.com/Resolving www.sohu.com (www.sohu.com)... 14.18.240.6Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 212527 (208K) [text/html]Saving to: ‘sohu.html’100%[==================================================&gt;] 212,527 --.-K/s in 0.03s2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527][root@guotz ~]# cat sohu.html...[root@guotz ~]# head -10 sohu.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;搜狐&lt;/title&gt;&lt;meta name=\"Keywords\" content=\"搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧\"/&gt;&lt;meta name=\"Description\" content=\"搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。\" /&gt;&lt;meta name=\"shenma-site-verification\" content=\"1237e4d02a3d8d73e96cbd97b699e9c3_1504254750\"&gt;&lt;meta charset=\"utf-8\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\"/&gt;[root@guotz ~]# tail -2 sohu.html&lt;/body&gt;&lt;/html&gt;[root@guotz ~]# less sohu.html...[root@guotz ~]# cat -n sohu.html | more... 拷贝/移动文件 - cp / mv。 12345678[root@guotz ~]# mkdir backup[root@guotz ~]# cp sohu.html backup/[root@guotz ~]# cd backup[root@guotz backup]# lssohu.html[root@guotz backup]# mv sohu.html sohu_index.html[root@guotz backup]# lssohu_index.html 查找文件和查找内容 - find / grep。 1234567891011121314151617[root@guotz ~]# find / -name \"*.html\"/root/sohu.html/root/backup/sohu_index.html[root@guotz ~]# find . -atime 7 -type f -print[root@guotz ~]# find . -type f -size +2k[root@guotz ~]# find . -type f -name \"*.swp\" -delete[root@guotz ~]# grep \"&lt;script&gt;\" sohu.html -n20:&lt;script&gt;[root@guotz ~]# grep -E \\&lt;\\/?script.*\\&gt; sohu.html -n20:&lt;script&gt;22:&lt;/script&gt;24:&lt;script src=\"//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js\"&gt;&lt;/script&gt;25:&lt;script src=\"//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js\"&gt;&lt;/script&gt;26:&lt;script src=\"//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js\"&gt;&lt;/script&gt;29:&lt;script type=\"text/javascript\"&gt;52:&lt;/script&gt;... 说明：grep在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用grep -E或者直接使用egrep。 链接 - ln。 123456789101112131415[root@guotz ~]# ls -l sohu.html-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html[root@guotz ~]# ln /root/sohu.html /root/backup/sohu_backup[root@guotz ~]# ls -l sohu.html-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html[root@guotz ~]# ln /root/sohu.html /root/backup/sohu_backup2[root@guotz ~]# ls -l sohu.html-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html[root@guotz ~]# ln -s /etc/centos-release sysinfo[root@guotz ~]# ls -l sysinfolrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; /etc/centos-release[root@guotz ~]# cat sysinfoCentOS Linux release 7.4.1708 (Core)[root@guotz ~]# cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core) 说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。 压缩/解压缩和归档/解归档 - gzip / gunzip / xz / tar。 1234567891011121314151617181920212223242526272829303132333435[root@guotz ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz--2018-06-20 19:29:59-- http://download.redis.io/releases/redis-4.0.10.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1738465 (1.7M) [application/x-gzip]Saving to: ‘redis-4.0.10.tar.gz’100%[==================================================&gt;] 1,738,465 70.1KB/s in 74s2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465][root@guotz ~]# ls redis*redis-4.0.10.tar.gz[root@guotz ~]# gunzip redis-4.0.10.tar.gz[root@guotz ~]# ls redis*redis-4.0.10.tar[root@guotz ~]# tar -xvf redis-4.0.10.tarredis-4.0.10/redis-4.0.10/.gitignoreredis-4.0.10/00-RELEASENOTESredis-4.0.10/BUGSredis-4.0.10/CONTRIBUTINGredis-4.0.10/COPYINGredis-4.0.10/INSTALLredis-4.0.10/MANIFESTOredis-4.0.10/Makefileredis-4.0.10/README.mdredis-4.0.10/deps/redis-4.0.10/deps/Makefileredis-4.0.10/deps/README.md...[root@guotz ~]# ls redis*redis-4.0.10.tarredis-4.0.10:00-RELEASENOTES COPYING Makefile redis.conf runtest-sentinel testsBUGS deps MANIFESTO runtest sentinel.conf utilsCONTRIBUTING INSTALL README.md runtest-cluster src 其他工具 - sort / uniq / diff / tr / cut / paste / file / wc。 123456789101112131415161718192021222324252627282930313233343536373839[root@guotz ~]# cat foo.txtgrapeapplepitaya[root@guotz ~]# cat bar.txt100200300400[root@guotz ~]# paste foo.txt bar.txtgrape 100apple 200pitaya 300 400[root@guotz ~]# paste foo.txt bar.txt &gt; hello.txt[root@guotz ~]# cut -b 4-8 hello.txtpe 10le 20aya 30[root@guotz ~]# cat hello.txt | tr '\\t' ','grape,100apple,200pitaya,300,400[root@guotz ~]# wget https://www.baidu.com/img/bd_logo1.png--2018-06-20 18:46:53-- https://www.baidu.com/img/bd_logo1.pngResolving www.baidu.com (www.baidu.com)... 220.181.111.188, 220.181.112.244Connecting to www.baidu.com (www.baidu.com)|220.181.111.188|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 7877 (7.7K) [image/png]Saving to: ‘bd_logo1.png’100%[==================================================&gt;] 7,877 --.-K/s in 0s2018-06-20 18:46:53 (118 MB/s) - ‘bd_logo1.png’ saved [7877/7877][root@guotz ~]# file bd_logo1.pngbd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced[root@guotz ~]# wc sohu.html2979 6355 212527 sohu.html[root@guotz ~]# wc -l sohu.html2979 sohu.html 管道和重定向 管道的使用 - \\|。 例子：查找当前目录下文件个数。 12[root@guotz ~]# find ./ | wc -l6152 例子：列出当前路径下的文件和文件夹，给每一项加一个编号。 123456[root@guotz ~]# ls | cat -n 1 dump.rdb 2 mongodb-3.6.5 3 Python-3.6.5 4 redis-3.2.11 5 redis.conf 例子：查找record.log中包含AAA，但不包含BBB的记录的总数 1[root@guotz ~]# cat record.log | grep AAA | grep -v BBB | wc -l 输出重定向和错误重定向 - \\&gt; / &gt;&gt; / 2\\&gt;。 1234567891011121314151617[root@guotz ~]# cat readme.txtbananaapplegrapeapplegrapewatermelonpearpitaya[root@guotz ~]# cat readme.txt | sort | uniq &gt; result.txt[root@guotz ~]# cat result.txtapplebananagrapepearpitayawatermelon 输入重定向 - \\&lt;。 1234567891011[root@guotz ~]# echo 'hello, world!' &gt; hello.txt[root@guotz ~]# wall &lt; hello.txt[root@guotz ~]#Broadcast message from root@guotz (Wed Jun 20 19:43:05 2018):hello, world![root@guotz ~]# echo 'I will show you some code.' &gt;&gt; hello.txt[root@guotz ~]# wall &lt; hello.txt[root@guotz ~]#Broadcast message from root@guotz (Wed Jun 20 19:43:55 2018):hello, world!I will show you some code. 别名 alias 1234567[root@guotz ~]# alias ll='ls -l'[root@guotz ~]# alias frm='rm -rf'[root@guotz ~]# ll...drwxr-xr-x 2 root root 4096 Jun 20 12:52 abc...[root@guotz ~]# frm abc unalias 123[root@guotz ~]# unalias frm[root@guotz ~]# frm sohu.html-bash: frm: command not found 其他程序 时间和日期 - date / cal。 123456789101112131415161718[root@guotz ~]# dateWed Jun 20 12:53:19 CST 2018[root@guotz ~]# cal June 2018Su Mo Tu We Th Fr Sa 1 23 4 5 6 7 8 910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30[root@guotz ~]# cal 5 2017 May 2017Su Mo Tu We Th Fr Sa 1 2 3 4 5 67 8 9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31 录制操作脚本 - script。 给用户发送消息 - mesg / write / wall / mail。 文件系统文件和路径 命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过\\对空格进行转义。 扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像file命令在识别文件时并不是依据扩展名来判定文件的类型。 隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。 目录结构 /bin - 基本命令的二进制文件。 /boot - 引导加载程序的静态文件。 /dev - 设备文件。 /etc - 配置文件。 /home - 普通用户主目录的父目录。 /lib - 共享库文件。 /lib64 - 共享64位库文件。 /lost+found - 存放未链接文件。 /media - 自动识别设备的挂载目录。 /mnt - 临时挂载文件系统的挂载点。 /opt - 可选插件软件包安装位置。 /proc - 内核和进程信息。 /root - 超级管理员用户主目录。 /run - 存放系统运行时需要的东西。 /sbin - 超级用户的二进制文件。 /sys - 设备的伪文件系统。 /tmp - 临时文件夹。 /usr - 用户应用目录。 /var - 变量数据目录。 访问权限 chmod - 改变文件模式比特。 1234567891011121314[root@guotz ~]# ls -l...-rw-r--r-- 1 root root 211878 Jun 19 16:06 sohu.html...[root@guotz ~]# chmod g+w,o+w sohu.html[root@guotz ~]# ls -l...-rw-rw-rw- 1 root root 211878 Jun 19 16:06 sohu.html...[root@guotz ~]# chmod 644 sohu.html[root@guotz ~]# ls -l...-rw-r--r-- 1 root root 211878 Jun 19 16:06 sohu.html... 说明：通过上面的例子可以看出，用chmod改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了chmod之外，可以通过umask来设定哪些权限将在新文件的默认权限中被删除。 长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。 chown - 改变文件所有者。 123456789[root@guotz ~]# ls -l...-rw-r--r-- 1 root root 54 Jun 20 10:06 readme.txt...[root@guotz ~]# chown hellokitty readme.txt[root@guotz ~]# ls -l...-rw-r--r-- 1 hellokitty root 54 Jun 20 10:06 readme.txt... 磁盘管理 列出文件系统的磁盘使用状况 - df。 12345678[root@guotz ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 5.0G 33G 14% /devtmpfs 486M 0 486M 0% /devtmpfs 497M 0 497M 0% /dev/shmtmpfs 497M 356K 496M 1% /runtmpfs 497M 0 497M 0% /sys/fs/cgrouptmpfs 100M 0 100M 0% /run/user/0 磁盘分区表操作 - fdisk。 12345678910111213[root@guotz ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000a42f4 Device Boot Start End Blocks Id System/dev/vda1 * 2048 83884031 41940992 83 LinuxDisk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes 格式化文件系统 - mkfs。 文件系统检查 - fsck。 挂载/卸载 - mount / umount。 编辑器 - vim 启动vim。可以通过vi或vim命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。 1[root@guotz ~]# vim guess.py 命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母i会进入编辑模式（Insert模式），屏幕下方出现-- INSERT --提示；在编辑模式下按下Esc会回到命令模式，此时如果输入英文:会进入末行模式，在末行模式下输入q!可以在不保存当前工作的情况下强行退出vim；在命令模式下输入v会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。 保存和退出vim：在命令模式下输入: 进入末行模式，输入wq可以实现保存退出；如果想放弃编辑的内容输入q!强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入ZZ实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入w；可以在w后面输入空格再指定要保存的文件名。 光标操作。 在命令模式下可以通过h、j、k、l来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：10h表示向左移动10个字符。 在命令模式下可以通过Ctrl+y和Ctrl+e来实现向上、向下滚动一行文本的操作，可以通过Ctrl+f和Ctrl+b来实现向前和向后翻页的操作。 在命令模式下可以通过输入英文字母G将光标移到文件的末尾，可以通过gg将光标移到文件的开始，也可以通过在G前输入数字来将光标移动到指定的行。 文本操作。 删除：在命令模式下可以用dd来删除整行；可以在dd前加数字来指定删除的行数；可以用d$来实现删除从光标处删到行尾的操作，也可以通过d0来实现从光标处删到行首的操作；如果想删除一个单词，可以使用dw；如果要删除全文，可以在输入:%d（其中:用来从命令模式进入末行模式）。 复制和粘贴：在命令模式下可以用yy来复制整行；可以在yy前加数字来指定复制的行数；可以通过p将复制的内容粘贴到光标所在的地方。 撤销和恢复：在命令模式下输入u可以撤销之前的操作；通过Ctrl+r可以恢复被撤销的操作。 对内容进行排序：在命令模式下输入%!sort。 查找和替换。 查找操作需要输入/进入末行模式并提供正则表达式来匹配与之对应的内容，例如：/doc.*\\.，输入n来向前搜索，也可以输入N来向后搜索。 替换操作需要输入:进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：:1,$s/doc.*/hello/gice，其中： g - global：全局匹配。 i - ignore case：忽略大小写匹配。 c - confirm：替换时需要确认。 e - error：忽略错误。 参数设定：在输入:进入末行模式后可以对vim进行设定。 设置Tab键的空格数：set ts=4 设置显示/不显示行号：set nu / set nonu 设置启用/关闭高亮语法：syntax on / syntax off 设置显示标尺（光标所在的行和列）： set ruler 设置启用/关闭搜索结果高亮：set hls / set nohls 说明：如果希望上面的这些设定在每次启动vim时都能生效，需要将这些设定写到用户主目录下的.vimrc文件中。 高级技巧 比较多个文件。 1[root@guotz ~]# vim -d foo.txt bar.txt 打开多个文件。 1[root@guotz ~]# vim foo.txt bar.txt hello.txt 启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入ls查看到打开的三个文件，也可以在末行模式中输入b &lt;num&gt;来显示另一个文件，例如可以用:b 2将bar.txt显示出来，可以用:b 3将hello.txt显示出来。 拆分和切换窗口。 可以在末行模式中输入sp或vs来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次Ctrl+w就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。 映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。 例子1：在命令模式下输入F4执行从第一行开始删除10000行代码的操作。 :map &lt;F4&gt; gg10000dd。 例子2：在编辑模式下输入__main直接补全为if __name__ == '__main__':。 :inoremap __main if __name__ == '__main__': 说明：上面例子2的inoremap中的i表示映射的键在编辑模式使用， nore表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。 录制宏。 在命令模式下输入qa开始录制宏（其中a是寄存器的名字，也可以是其他英文字母或0-9的数字）。 执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。 如果录制的操作已经完成了，按q结束录制。 通过@a（a是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如100@a表示将宏播放100次。 可以试一试下面的例子来体验录制宏的操作，该例子来源于Harttle Land网站，该网站上提供了很多关于vim的使用技巧，有兴趣的可以去了解一下。 软件安装和配置使用包管理工具 yum - Yellowdog Updater Modified。 yum search：搜索软件包，例如yum search nginx。 yum list installed：列出已经安装的软件包，例如yum list installed | grep zlib。 yum install：安装软件包，例如yum install nginx。 yum remove：删除软件包，例如yum remove nginx。 yum update：更新软件包，例如yum update可以更新所有软件包，而yum update tar只会更新tar。 yum check-update：检查有哪些可以更新的软件包。 yum info：显示软件包的相关信息，例如yum info nginx。 rpm - Redhat Package Manager。 安装软件包：rpm -ivh &lt;packagename&gt;.rpm。 移除软件包：rpm -e &lt;packagename&gt;。 查询软件包：rpm -qa，例如可以用rpm -qa | grep mysql来检查是否安装了MySQL相关的软件包。 下面以Nginx为例，演示如何使用yum安装软件。 123456789101112131415161718192021222324252627282930313233[root@guotz ~]# yum -y install nginx...Installed:nginx.x86_64 1:1.12.2-2.el7Dependency Installed:nginx-all-modules.noarch 1:1.12.2-2.el7nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7nginx-mod-http-perl.x86_64 1:1.12.2-2.el7nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7nginx-mod-mail.x86_64 1:1.12.2-2.el7nginx-mod-stream.x86_64 1:1.12.2-2.el7Complete![root@guotz ~]# yum info nginxLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfileInstalled PackagesName : nginxArch : x86_64Epoch : 1Version : 1.12.2Release : 2.el7Size : 1.5 MRepo : installedFrom repo : epelSummary : A high performance web server and reverse proxy serverURL : http://nginx.org/License : BSDDescription : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and : IMAP protocols, with a strong focus on high concurrency, performance and low : memory usage.[root@guotz ~]# nginx -vnginx version: nginx/1.12.2 移除Nginx。 12[root@guotz ~]# nginx -s stop[root@guotz ~]# yum -y remove nginx 下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到MySQL官方网站下载对应的RPM文件，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。如果要安装MySQL需要先通过yum删除mariadb-libs这个可能会跟MySQL底层库冲突的库，然后还需要安装一个名为libaio的依赖库。 1234567891011[root@guotz mysql]# lsmysql-community-client-5.7.22-1.el7.x86_64.rpmmysql-community-common-5.7.22-1.el7.x86_64.rpmmysql-community-libs-5.7.22-1.el7.x86_64.rpmmysql-community-server-5.7.22-1.el7.x86_64.rpm[root@guotz mysql]# yum -y remove mariadb-libs[root@guotz mysql]# yum -y install libaio[root@guotz mysql]# ls | xargs rpm -ivhwarning: mysql-community-client-5.7.22-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing... ################################# [100%]... 说明：由于MySQL和MariaDB的底层依赖库是有冲突的，所以上面我们首先用yum移除了名为mariadb-libs的依赖库并安装了名为libaio的依赖库。由于我们将安装MySQL所需的rpm文件放在一个独立的目录中，所以可以通过ls命令查看到安装文件并用xargs将ls的输出作为参数交给rpm -ivh来进行安装。关于MySQL和MariaDB之间的关系，可以阅读维基百科上关于MariaDB的介绍。 移除安装的MySQL。 1[root@guotz ~]# rpm -qa | grep mysql | xargs rpm -e 下载解压配置环境变量下面以安装MongoDB为例，演示这类软件应该如何安装。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[root@guotz ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz--2018-06-21 18:32:53-- https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgzResolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 100564462 (96M) [application/x-gzip]Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’100%[==================================================&gt;] 100,564,462 630KB/s in 2m 9s2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462][root@guotz ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz[root@guotz ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tarmongodb-linux-x86_64-rhel70-3.6.5/READMEmongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICESmongodb-linux-x86_64-rhel70-3.6.5/MPL-2mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestoremongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimportmongodb-linux-x86_64-rhel70-3.6.5/bin/mongostatmongodb-linux-x86_64-rhel70-3.6.5/bin/mongotopmongodb-linux-x86_64-rhel70-3.6.5/bin/bsondumpmongodb-linux-x86_64-rhel70-3.6.5/bin/mongofilesmongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplaymongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperfmongodb-linux-x86_64-rhel70-3.6.5/bin/mongodmongodb-linux-x86_64-rhel70-3.6.5/bin/mongosmongodb-linux-x86_64-rhel70-3.6.5/bin/mongomongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass[root@guotz ~]# vim .bash_profile...PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/binexport PATH...[root@guotz ~]# source .bash_profile[root@guotz ~]# mongod --versiondb version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:distmod: rhel70distarch: x86_64target_arch: x86_64[root@guotz ~]# mongo --versionMongoDB shell version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:distmod: rhel70distarch: x86_64target_arch: x86_64 说明：当然也可以通过yum来安装MongoDB，具体可以参照官方网站上给出的说明。 源代码构建安装 安装Python 3.6。 1234567891011121314[root@guotz ~]# yum install gcc[root@guotz ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz[root@guotz ~]# gunzip Python-3.6.5.tgz[root@guotz ~]# tar -xvf Python-3.6.5.tar[root@guotz ~]# cd Python-3.6.5[root@guotz ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations[root@guotz ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel[root@guotz ~]# make &amp;&amp; make install... 配置环境变量 ...[root@guotz ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3[root@guotz ~]# python3 --versionPython 3.6.5[root@guotz ~]# python3 -m pip install -U pip[root@guotz ~]# pip3 --version 安装Redis-3.2.12。 123456789[root@guotz ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz[root@guotz ~]# gunzip redis-3.2.12.tar.gz[root@guotz ~]# tar -xvf redis-3.2.12.tar[root@guotz ~]# cd redis-3.2.12[root@guotz ~]# make &amp;&amp; make install[root@guotz ~]# redis-server --versionRedis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6[root@guotz ~]# redis-cli --versionredis-cli 3.2.12 配置服务 启动服务。 1[root@guotz ~]# systemctl start firewalld 终止服务。 1[root@guotz ~]# systemctl stop firewalld 重启服务。 1[root@guotz ~]# systemctl restart firewalld 查看服务。 1[root@guotz ~]# systemctl status firewalld 设置是否开机自启。 123456[root@guotz ~]# systemctl enable firewalldCreated symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.[root@guotz ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 计划任务 crontab命令。 123[root@guotz ~]# crontab -e* * * * * echo \"hello, world!\" &gt;&gt; /root/hello.txt59 23 * * * rm -f /root/*.log 说明：输入crontab -e命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向/root目录下的hello.txt中追加输出hello, world!；另一个是每天23时59分执行删除/root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照/etc/crontab文件中的提示（下面会讲到）或者用谷歌或百度搜索一下，也可以使用Cron表达式在线生成器来生成Cron表达式。 crontab相关文件。 12345678910111213141516171819202122232425[root@guotz ~]# cd /etc[root@guotz etc]# ls -l | grep cron-rw-------. 1 root root 541 Aug 3 2017 anacrontabdrwxr-xr-x. 2 root root 4096 Mar 27 11:56 cron.ddrwxr-xr-x. 2 root root 4096 Mar 27 11:51 cron.daily-rw-------. 1 root root 0 Aug 3 2017 cron.denydrwxr-xr-x. 2 root root 4096 Mar 27 11:50 cron.hourlydrwxr-xr-x. 2 root root 4096 Jun 10 2014 cron.monthly-rw-r--r-- 1 root root 493 Jun 23 15:09 crontabdrwxr-xr-x. 2 root root 4096 Jun 10 2014 cron.weekly[root@guotz etc]# vim crontab 1 SHELL=/bin/bash 2 PATH=/sbin:/bin:/usr/sbin:/usr/bin 3 MAILTO=root 4 5 # For details see man 4 crontabs 6 7 # Example of job definition: 8 # .---------------- minute (0 - 59) 9 # | .------------- hour (0 - 23)10 # | | .---------- day of month (1 - 31)11 # | | | .------- month (1 - 12) OR jan,feb,mar,apr ...12 # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat13 # | | | | |14 # * * * * * user-name command to be executed 通过修改/etc目录下的crontab文件也能够定制计划任务。 网络访问和管理 安全远程连接 - ssh。 通过网络获取资源 - wget。 -b 后台下载模式 -O 下载到指定的目录 -r 递归下载 显示/操作网络配置（旧） - ifconfig。 12345678[root@guotz ~]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.18.61.250 netmask 255.255.240.0 broadcast 172.18.63.255 ether 00:16:3e:02:b6:46 txqueuelen 1000 (Ethernet) RX packets 1067841 bytes 1296732947 (1.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 409912 bytes 43569163 (41.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 显示/操作网络配置（新） - ip。 123456789[root@guotz ~]# ip address1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0 valid_lft forever preferred_lft forever 网络可达性检查 - ping。 12345678[root@guotz ~]# ping www.baidu.com -c 3PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms 查看网络服务和端口 - netstat。 1[root@guotz ~]# netstat -nap | grep nginx 安全文件拷贝 - scp。 1[root@guotz ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg 安全文件传输 - sftp。 1234[root@guotz ~]# sftp root@120.77.222.217root@120.77.222.217's password:Connected to 120.77.222.217.sftp&gt; help：显示帮助信息。 ls/lls：显示远端/本地目录列表。 cd/lcd：切换远端/本地路径。 mkdir/lmkdir：创建远端/本地目录。 pwd/lpwd：显示远端/本地当前工作目录。 get：下载文件。 put：上传文件。 rm：删除远端文件。 bye/exit/quit：退出sftp。 进程管理 ps - 查询进程。 12345678[root@guotz ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Jun23 ? 00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21root 2 0 0 Jun23 ? 00:00:00 [kthreadd]...[root@guotz ~]# ps -ef | grep mysqldroot 4943 4581 0 22:45 pts/0 00:00:00 grep --color=auto mysqldmysql 25257 1 0 Jun25 ? 00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid kill - 终止进程。 12[root@guotz ~]# kill 1234[root@guotz ~]# kill -9 1234 例子：用一条命令强制终止正在运行的Redis进程。 1ps -ef | grep redis | grep -v grep | awk '{print $2}' | xargs kill 将进程置于后台运行。 Ctrl+Z &amp; 12345[root@guotz ~]# mongod &amp;[root@guotz ~]# redis-server...^Z[4]+ Stopped redis-server jobs - 查询后台进程。 1234[root@guotz ~]# jobs[2] Running mongod &amp;[3]- Stopped cat[4]+ Stopped redis-server bg - 让进程在后台继续运行。 123456[root@guotz ~]# bg %4[4]+ redis-server &amp;[root@guotz ~]# jobs[2] Running mongod &amp;[3]+ Stopped cat[4]- Running redis-server &amp; fg - 将后台进程置于前台。 1234567[root@guotz ~]# fg %4redis-server^C5554:signal-handler (1530025281) Received SIGINT scheduling shutdown...5554:M 26 Jun 23:01:21.413 # User requested shutdown...5554:M 26 Jun 23:01:21.413 * Saving the final RDB snapshot before exiting.5554:M 26 Jun 23:01:21.415 * DB saved on disk5554:M 26 Jun 23:01:21.415 # Redis is now ready to exit, bye bye... 说明：置于前台的进程可以使用Ctrl+C来终止它。 top - 进程监控。 1234567[root@guotz ~]# toptop - 23:04:23 up 3 days, 14:10, 1 user, load average: 0.00, 0.01, 0.05Tasks: 65 total, 1 running, 64 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016168 total, 191060 free, 324700 used, 500408 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 530944 avail Mem... 系统性能 查看系统活动信息 - sar。 查看内存使用情况 - free。 1234[root@guotz ~]# free total used free shared buff/cache availableMem: 1016168 323924 190452 356 501792 531800Swap: 0 0 0 查看进程使用内存状况 - pmap。 1234567891011121314[root@guotz ~]# ps PID TTY TIME CMD4581 pts/0 00:00:00 bash5664 pts/0 00:00:00 ps[root@guotz ~]# pmap 45814581: -bash0000000000400000 884K r-x-- bash00000000006dc000 4K r---- bash00000000006dd000 36K rw--- bash00000000006e6000 24K rw--- [ anon ]0000000001de0000 400K rw--- [ anon ]00007f82fe805000 48K r-x-- libnss_files-2.17.so00007f82fe811000 2044K ----- libnss_files-2.17.so... 报告设备CPU和I/O统计信息 - iostat。 1234567[root@guotz ~]# iostatLinux 3.10.0-693.11.1.el7.x86_64 (guotz) 06/26/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.79 0.00 0.20 0.04 0.00 98.97Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.85 6.78 21.32 2106565 6623024vdb 0.00 0.01 0.00 2088 0","link":"/2018/02/09/玩转Linux/"},{"title":"数据结构之数组实现","text":"动态数组的底层实现Java中的数组静态数组作为java的一种容器，数组的优缺点同样明显 优点：使用简单 ，查询效率高，内存为连续的区域 缺点：大小固定，不适合动态存储，不方便动态添加 Java中定义数组的三种形式12345678// 第一种：数组格式 类型[] 数组名 = new 类型[数组长度] int[] arr = new int[10];// 第二种：定义数组，直接赋值 int[] arr = new int[]{11, 22, 33, 44};// 第三种：定义数组，直接赋值 int[] arr = {11, 22, 33, 44}; 自定义数组 为了加深对数组的理解，实现自定义数组，定义数组的动态扩减容，且自动维护数组的大小size，从而节省了内存空间资源。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/* 创建动态数组 */public class MyArray&lt;E&gt; { /* 静态数组 */ private E[] data; /* 数组元素的数量 */ private int size; public MyArray() { new MyArray&lt;E&gt;(20); } public MyArray(int count) { data = (E[]) new Object[count]; size = 0; } /** * 获取数组元素的数量 * * @return */ public int size() { return size; } /** * 判断数组是否为空 * * @return */ public boolean isEmpty() { return size == 0; } /** * 获取数组任意节点的值 * * @param index * @return */ public E get(int index) { if (index &lt; 0 &amp;&amp; index &gt;= data.length) { throw new IllegalArgumentException(\"index 越界\"); } return data[index]; } /** * 给数组索引index对应的位置赋值 * * @param index * @param e */ public void set(int index, E e) { if (index &lt; 0 &amp;&amp; index &gt;= data.length) { throw new IllegalArgumentException(\"index 越界\"); } data[index] = e; } /* 获取数组的第一个元素 */ public E first() { return get(0); } /* 获取数组的最后一个元素 */ public E lest() { return get(size); } /* 在数组的第一个位置添加元素 */ public void addFirst(E e) { add(0, e); } /* 在数组的末尾添加元素 */ public void addLest(E e) { add(size, e); } /** * 添加元素到数组的任意位置 * * @param index 索引位置 * @param e 值 */ public void add(int index, E e) { if (index &lt; 0 &amp;&amp; index &gt;= data.length) { throw new IllegalArgumentException(\"index 越界\"); } if (e == null) { throw new IllegalArgumentException(\"array 的每一项都不能为空\"); } if (size == data.length) { // 扩容 resize(2 * size); } for (int i = size - 1; i &gt;= index; i--) { data[i + 1] = data[i]; } size++; data[index] = e; } /** * 删除索引index的值 * * @param index * @return */ public E remove(int index) { if (index &lt; 0 &amp;&amp; index &gt;= data.length) { throw new IllegalArgumentException(\"index 越界\"); } E e = data[index]; data[index] = null; for (int i = index; i &lt; size; i++) { data[i] = data[i + 1]; } size--; if (size == (data.length / 4)) { // 扩容 resize(data.length / 2); } return e; } /** * 判断数组是否包含元素e * * @param e * @return */ public boolean contains(E e) { for (int i = 0; i &lt; size; i++) { E value = data[i]; if (e == value) return true; } return false; } /** * 查询数组中元素e对应的索引 * * @param e * @return 如果存在元素e 返回对应的索引 如果不存在则返回-1 */ public int find(E e) { for (int i = 0; i &lt; size; i++) { E value = data[i]; if (value == e) return i; } return -1; } @Override public String toString() { StringBuffer str = new StringBuffer(); str.append(\"[\"); for (int i = 0; i &lt; size; i++) { str.append(data[i]); if (i != size - 1) { str.append(\",\"); } } str.append(\"]\"); return str.toString(); } /** * 对数组进行扩容 * * @param count */ private void resize(int count) { E[] newdata = (E[]) new Object[count]; for (int i = 0; i &lt; size; i++) { newdata[i] = data[i]; } data = newdata; }}","link":"/2017/09/12/数据结构之数组实现/"}],"tags":[{"name":"MD5加密","slug":"MD5加密","link":"/tags/MD5加密/"},{"name":"RSA加密","slug":"RSA加密","link":"/tags/RSA加密/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"版本控制","slug":"版本控制","link":"/tags/版本控制/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"第三方库","slug":"第三方库","link":"/tags/第三方库/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"二分搜索树","slug":"二分搜索树","link":"/tags/二分搜索树/"},{"name":"哈希表","slug":"哈希表","link":"/tags/哈希表/"},{"name":"散列表","slug":"散列表","link":"/tags/散列表/"},{"name":"字典","slug":"字典","link":"/tags/字典/"},{"name":"dict","slug":"dict","link":"/tags/dict/"},{"name":"映射","slug":"映射","link":"/tags/映射/"},{"name":"LinkedMap","slug":"LinkedMap","link":"/tags/LinkedMap/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"TreeMap","slug":"TreeMap","link":"/tags/TreeMap/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"集合","slug":"集合","link":"/tags/集合/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"CLang","slug":"CLang","link":"/tags/CLang/"},{"name":"二叉堆","slug":"二叉堆","link":"/tags/二叉堆/"},{"name":"优先队列","slug":"优先队列","link":"/tags/优先队列/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"数组","slug":"数组","link":"/tags/数组/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"Apache服务器","slug":"后端/Apache服务器","link":"/categories/后端/Apache服务器/"},{"name":"Django","slug":"后端/Django","link":"/categories/后端/Django/"},{"name":"系统","slug":"系统","link":"/categories/系统/"},{"name":"Nginx服务器","slug":"后端/Nginx服务器","link":"/categories/后端/Nginx服务器/"},{"name":"DataBase","slug":"DataBase","link":"/categories/DataBase/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"插件","slug":"插件","link":"/categories/插件/"},{"name":"Mac","slug":"系统/Mac","link":"/categories/系统/Mac/"},{"name":"NoSQL","slug":"DataBase/NoSQL","link":"/categories/DataBase/NoSQL/"},{"name":"Linux","slug":"系统/Linux","link":"/categories/系统/Linux/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"Swift","slug":"iOS/Swift","link":"/categories/iOS/Swift/"},{"name":"Objective-C","slug":"iOS/Objective-C","link":"/categories/iOS/Objective-C/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"编译","slug":"编译","link":"/categories/编译/"},{"name":"swift","slug":"iOS/swift","link":"/categories/iOS/swift/"},{"name":"编译","slug":"iOS/编译","link":"/categories/iOS/编译/"},{"name":"Mysql","slug":"DataBase/Mysql","link":"/categories/DataBase/Mysql/"},{"name":"二叉树","slug":"数据结构/二叉树","link":"/categories/数据结构/二叉树/"},{"name":"哈希表","slug":"数据结构/哈希表","link":"/categories/数据结构/哈希表/"},{"name":"字典Map","slug":"数据结构/字典Map","link":"/categories/数据结构/字典Map/"},{"name":"栈","slug":"数据结构/栈","link":"/categories/数据结构/栈/"},{"name":"链表","slug":"数据结构/链表","link":"/categories/数据结构/链表/"},{"name":"队列","slug":"数据结构/队列","link":"/categories/数据结构/队列/"},{"name":"集合","slug":"数据结构/集合","link":"/categories/数据结构/集合/"},{"name":"排序算法","slug":"算法/排序算法","link":"/categories/算法/排序算法/"},{"name":"LLVM","slug":"编译/LLVM","link":"/categories/编译/LLVM/"},{"name":"二叉堆","slug":"数据结构/二叉堆","link":"/categories/数据结构/二叉堆/"},{"name":"数组","slug":"数据结构/数组","link":"/categories/数据结构/数组/"}]}